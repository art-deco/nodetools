{
  "title": "Web Development With NodeTools",
  "content": "\n\n<div data-section id=\"web-development\">\n<h1>Web Development With NodeTools</h1>\n\n<p>The primary aim of <em>NodeTools</em> is to help package makers with back-end packages. <span class=\"tm\">NodeTools 2</span> will be based on the groundwork from the first version, and facilitate rapid web development, via more advanced tools such as:</p>\n\n<ul>\n  <li><strong>Splendid</strong>, a static-website compiler for hybrid HTML + JSX pages that are written as static HTML, and only include dynamic components where they need to be. There's also great support for Bootstrap: <p><img alt=\"bootstrap autocompletion support\" data-io>\n<noscript><img alt=\"bootstrap autocompletion support\" src=\"/nodetools/pages/web/img/splendid.png\"></noscript></p></li>\n  <li><strong>Idio</strong>, a full-scale web-server with all essential middleware that was built with a compiler and has only 2 dependencies and provides a front-end middleware for serving JSX and <span class=\"tm\">node_modules</span>.</li>\n</ul>\n\n<p>We plan to release <strong>Irio</strong> which is the combination of the two of the above to become world's tidiest, most intuitive, professional web-framework. But while the work is in progress, let me just give a few hints of how to develop client-side JS code and compile it with <em>Closure</em>, based on some packages that I've made.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='15'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/0.svg\"></noscript></a>\n</p>\n</div>\n\n\n<div data-section id=\"front-end-middleware\">\n<h2>Front-End Middleware</h2>\n\n<p>Traditionally, you would use complex build tools like <em>WebPack</em> to package your code and run a development server. Since all current browsers are mature enough to support modern JavaScript, including modules, destructuring, <em>etc</em>, I don't see the need to transpile your code when developing it. You can just serve it as it is, with only 2 exceptions:</p>\n\n<ul>\n  <li>When importing from <span class=\"tm\">node_modules</span>, the imports need to be renamed from <span class=\"tm2\">import { test } from 'example'</span> to <span class=\"tm2\">import { test } from '/node_modules/example/src/index.mjs'</span>.</li>\n  <li>JSX is not understood by the browser, therefore needs to be modified being being served.</li>\n</ul>\n\n<p>Those are not hard requirements. When a browser requests a file, instead of serving the file from the filesystem, we can modify it by implementing a server middleware, that would adapt the file to meet the two requirements from the above. This middleware is available via the <span class=\"tm\">@idio/frontend</span> package, and is able to serve <span class=\"tm\">node_modules</span> and transpile JSX with RegExp. There are some limitations to JSX until <em>NodeTools 2</em> are properly released, e.g.,</p>\n\n<ul>\n  <li>There are no source maps for debugging.</li>\n  <li>There's no hot module reload.</li>\n  <li>JSX does not support block comments.\n<pre id=\"ccdbf10\"><code class=\"javascript hljs\">render(&lt;div&gt;\n  {/* hello world */}\n&lt;/div&gt;)</code></pre>\n  </li>\n  <li>No curly braces in components' attributes are allowed <span class=\"tm\">render(&lt;div title=&quot;hello{world}&quot;/&gt;)</span>.</li>\n  <li>No <span class=\"tm\">&gt;</span> sign inside components is permitted.</li>\n</ul>\n\n<p>It's fair enough if those limitations might deter you from using our method. On the other hand, you can literally get going with only 3 new folders in you <span class=\"tm\">node_modules</span> (<em>Idio</em> web server) so if the simplicity of use outweighs these drawbacks, you can give it a go. The complexity of the project doesn't matter, and it's primarily the hot-module reload that might be the missing link, but we'll make it possible ASAP.</p>\n\n<p>After your JS code is ready, you can compile it into a single file with <em>Closure Compiler</em>. If you used JSX, we'll transpile it with <em>√ÄLaMode</em>, and put the intermediary code in the temp folder. The compiler will also add necessary polyfills for the target language (default is ES5) and update newer constructs such as <span class=\"tm2\">async/await</span> and <span class=\"tm2\">{ destructuring }</span> so that it can run in older browsers.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/1.svg\"></noscript></a>\n</p>\n</div>\n\n<div data-section id=\"setting-up\">\n<h2>Setting Up</h2>\n\n<p>There's a more complex <span class=\"tm2\">mnpjs/idio</span> MNP config that is a template for a web-server. However, it's not the purpose of this article to show how to create a full-stack application. I'll leave it for another time. I just wanted to show how to develop and compile a front-end.</p>\n\n<p>As I mentioned, you'll need the <span class=\"tm\">@idio/idio</span> server (a Koa fork itself, but completely rewritten for Closure). Let's install it with <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-cmd\">i</span><span class=\"yarn-cmd\">add</span> <span>@idio/idio</span></span></span>. We'll then want to create a basic configuration to start it:</p>\n\n<pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> idio <span class=\"token keyword\">from</span> <span class=\"token string\">'@idio/idio'</span>\n<span class=\"token keyword\">import</span> render <span class=\"token keyword\">from</span> <span class=\"token string\">'@depack/render'</span>\n<span class=\"token keyword\">import</span> api <span class=\"token keyword\">from</span> <span class=\"token string\">'./routes/api'</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token constant\">PREACT</span> <span class=\"token operator\">=</span> <span class=\"token string\">'https://cdnjs.cloudflare.com/ajax/libs/'</span> <span class=\"token operator\">+</span>\n               <span class=\"token string\">'preact/8.5.3/preact.umd.js'</span>\n\n<span class=\"token punctuation\">;</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token constant\">PROD</span> <span class=\"token operator\">=</span> process<span class=\"token punctuation\">.</span>env<span class=\"token punctuation\">.</span><span class=\"token constant\">CLOSURE</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> app<span class=\"token punctuation\">,</span> url<span class=\"token punctuation\">,</span> router <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">idio</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">static</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      root<span class=\"token operator\">:</span> <span class=\"token string\">'docs'</span><span class=\"token punctuation\">,</span>\n      use<span class=\"token operator\">:</span> <span class=\"token constant\">PROD</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    frontend<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      directory<span class=\"token operator\">:</span> <span class=\"token string\">'frontend'</span><span class=\"token punctuation\">,</span>\n      use<span class=\"token operator\">:</span> <span class=\"token operator\">!</span><span class=\"token constant\">PROD</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  router<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">ctx</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> script <span class=\"token operator\">=</span> <span class=\"token constant\">PROD</span> <span class=\"token operator\">?</span>\n      <span class=\"token operator\">&lt;</span>script src<span class=\"token operator\">=</span><span class=\"token string\">\"index.js\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span>\n      <span class=\"token operator\">&lt;</span>script type<span class=\"token operator\">=</span><span class=\"token string\">\"module\"</span> src<span class=\"token operator\">=</span><span class=\"token string\">\"frontend/\"</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    ctx<span class=\"token punctuation\">.</span>body <span class=\"token operator\">=</span> <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>h1<span class=\"token operator\">></span>Hello World<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>h1<span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>div id<span class=\"token operator\">=</span><span class=\"token string\">\"app\"</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>script src<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span><span class=\"token constant\">PREACT</span><span class=\"token punctuation\">}</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token punctuation\">{</span>script<span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">{</span>\n      addDoctype<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n  router<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api'</span><span class=\"token punctuation\">,</span> api<span class=\"token punctuation\">)</span>\n  app<span class=\"token punctuation\">.</span><span class=\"token function\">use</span><span class=\"token punctuation\">(</span>router<span class=\"token punctuation\">.</span><span class=\"token function\">routes</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span></code></pre>\n\n<p>This is a JSX file, meaning that we can render JSX components statically, using <span class=\"tm2\">@depack/render</span> package. It is a fork of <span class=\"tm2\">preact-render-to-html-string</span> with a few improvements, like the ability to add the doctype automatically. <em>Idio</em> is configured from the first argument called <em>MiddlewareConfig</em>. It accepts settings for all supported middleware. We'll only want 2 middleware: <span class=\"tm\">front-end</span> for development, and <span class=\"tm\">static</span>, when it comes to testing the production bundle of our JS code.</p>\n\n<p><span class=\"tm\">idio</span> method returns a URL and a router instance, that we use to set up the index path, and an api path. The index path will simply display a welcome message, and mount our component. Because we're using Preact, we'll want to make sure the library is available on the window scope, by installing it via a CDN. We could compile Preact into our library itself, however it would produce a lot of warnings as its annotations haven't been adapted to <em>Closure</em> in its source code. For development, we'll serve JavaScript as a module from <span class=\"tm\">frontend/index.jsx</span> file, but after we've built the bundle, we'd want to test if it's working from the <span class=\"tm\">docs</span> folder.</p>\n\n<p>Our API route from <span class=\"tm\">routes/api</span> is used for dynamic requests from the front-end application. We'll come back to it in a second.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/2.svg\"></noscript></a>\n</p>\n</div>\n\n\n\n<div data-section id=\"jsx-application\">\n<h2>JSX Application</h2>\n\n<p>The application that we create is very simple. It's just going fetch some data from the server, and display it to the user. Since JSX is the most convenient way for web development, we'll use it for our app. Data bindings and ability to write HTML within JS give such massive advantage over plain JS that it's pretty much essential to be using it. Likely, we don't need <em>Babel</em> or anything else to transpile JSX anymore, since <em>√ÄLaMode</em> can do it with a simple transpile based on regexes. Sure, it might fail occasionally for edge cases, but I haven't had any issues with it.</p>\n\n<pre class=\"language-jsx\"><code class=\"language-jsx\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> render<span class=\"token punctuation\">,</span> Component <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'preact'</span>\n<span class=\"token keyword\">import</span> fetch <span class=\"token keyword\">from</span> <span class=\"token string\">'unfetch'</span>\n<span class=\"token keyword\">import</span> <span class=\"token string\">'./style.css'</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">App</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Component</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">super</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n      data<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">/** @type {_nodetools.User} */</span>\n      user<span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> error<span class=\"token punctuation\">,</span> loading<span class=\"token punctuation\">,</span> user <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>loading<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>Loading<span class=\"token operator\">...</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>div className<span class=\"token operator\">=</span><span class=\"token string\">\"Error\"</span><span class=\"token operator\">></span>Error<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>error<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>div<span class=\"token operator\">></span>\n      Hello From Preact Component\n      <span class=\"token punctuation\">{</span>user <span class=\"token operator\">&amp;&amp;</span> <span class=\"token string\">', '</span><span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">{</span>user <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">&lt;</span>span className<span class=\"token operator\">=</span><span class=\"token string\">\"UserName\"</span><span class=\"token operator\">></span><span class=\"token punctuation\">{</span>user<span class=\"token punctuation\">.</span>name<span class=\"token punctuation\">}</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>span<span class=\"token operator\">></span><span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>div<span class=\"token operator\">></span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">componentDidMount</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">async</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> loading<span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/api'</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> error<span class=\"token punctuation\">,</span> user <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span>\n        <span class=\"token comment\">/** @type {!_nodetools.ServerResponse} */</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> res<span class=\"token punctuation\">.</span><span class=\"token function\">json</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>error<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> error <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> user <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">let</span> error <span class=\"token operator\">=</span> err\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>err <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Event</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        error <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span> message<span class=\"token operator\">:</span> <span class=\"token string\">'Network error'</span> <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> error <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">finally</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span><span class=\"token function\">setState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> loading<span class=\"token operator\">:</span> <span class=\"token boolean\">false</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token operator\">&lt;</span>App <span class=\"token operator\">/</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> window<span class=\"token punctuation\">[</span><span class=\"token string\">'app'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').ServerResponse} _nodetools.ServerResponse\n */</span>\n<span class=\"token comment\">/**\n * @suppress {nonStandardJsDocs}\n * @typedef {import('../types').User} _nodetools.User\n */</span></code></pre>\n\n<p>We'll render the app on the <span class=\"tm\">window.app</span> element (it's available on <span class=\"tm\">window</span> since we gave the div the <span class=\"tm2\">app</span> id). I prefer to make use of <span class=\"tm\">unfetch</span> package as <span class=\"tm2\">fetch</span> API is not supported by older browsers, and <em>Closure</em> doesn't provide a polyfill for it.</p>\n\n<p>As soon as the main component mounts, it will attempt to fetch data from the server. It then can be in 3 states:</p>\n\n<ul>\n  <li><strong>loading</strong>, when a request has been sent, but the response not received yet.</li>\n  <li><strong>error</strong>, if there was a server error, or an error during the request. We need to check if the caught error is an event, because in the <span class=\"tm\">fetch</span> library, it could be the case.</li>\n  <li><strong>data</strong>, when data is received.</li>\n</ul>\n\n<p>In our render method, we therefore extract the current state, and display the appropriate information. Because we used the <span class=\"tm\">setState</span> method, the application will be re-rendered automatically whenever the state changes.</p>\n\n<p>We also used an external type, called <span class=\"tm\">_nodetools.ServerResponse</span>. We used <strong>casting</strong> since the assignments were made via destructuring, so we couldn't just annotate it above the function.</p>\n\n<pre id=\"ccdbf\"><code class=\"javascript hljs\">const { error, user } =\n  /** @type {!_nodetools.ServerResponse} */ (await res.json())</code></pre>\n\n<p>This is when <em>NodeTools</em> with its typework come in handy again. We need to prepare types for A) our experience in VSCode, including auto-completions, and B) closure externs, so that the compiler doesn't mangle the properties of the received object. The types are defined in the <span class=\"tm\">types.xml</span> file.</p>\n\n<pre><code class=\"xml hljs\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">types</span> <span class=\"hljs-attr\">ns</span>=<span class=\"hljs-string\">\"_nodetools\"</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">record</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"ServerResponse\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">prop</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">\"!_nodetools.User\"</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"user\"</span> <span class=\"hljs-attr\">opt</span>&gt;</span>\n      The user object.\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">prop</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">prop</span> <span class=\"hljs-attr\">string</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"error\"</span>&gt;</span>\n      The server-side error.\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">prop</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">record</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">record</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"User\"</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">prop</span> <span class=\"hljs-attr\">string</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"name\"</span>&gt;</span>\n      The name of the user.\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">prop</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">prop</span> <span class=\"hljs-attr\">string</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">\"login\"</span>&gt;</span>\n      The unique login of the user.\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">prop</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">record</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">types</span>&gt;</span></code></pre>\n\n<p>We define a generic <em>ServerResponse</em> type that contains either an error, or some data, according to the route. Doing it this way, allows to implement a fetch function in a single place, and then access the required property, such as <span class=\"tm\">user</span> from within any component.</p>\n\n<div data-section id=\"css-loader\">\n<h3>CSS Loader</h3>\n\n<p>Importing styles is also supported via <span class=\"tm\">frontend</span> middleware. It will serve the CSS file as a JavaScript function, that adds the style to DOM dynamically. The import itself is not transpiled at all, but the server will assign the <span class=\"tm2\">application/javascript</span> mime type when service <strong>style.css</strong>. When <em>Depack</em> comes to generate temp code for the compiler, it will also create this .css.js file and pass its path to <em>Closure</em>.</p>\n\n</div>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='9'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/3.svg\"></noscript></a>\n</p>\n</div>\n\n\n\n<div data-section id=\"universal-types\">\n<h2>Universal Types</h2>\n\n<p>The types that we're using are applicable both for server-side an client-side, therefore we can reuse them by importing from both places. In code that's going to be compiled with <em>Closure</em> though, we need to add the <span class=\"tm\">@suppress</span> annotation, otherwise the compiler will print a warning. Although the compiler won't discover those types from source code, we'll pass it to it via externs. For back-end, we use simple <span class=\"tm\">import</span>. Below is our API route.</p>\n\n<pre><code class=\"js hljs\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">API</span> (<span class=\"hljs-params\">ctx</span>) </span>{\n  <span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">{_nodetools.User}</span> </span>*/</span>\n  <span class=\"hljs-keyword\">const</span> user = {\n    <span class=\"hljs-attr\">login</span>: <span class=\"hljs-string\">'test'</span>,\n    <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">'user'</span>,\n  }\n  <span class=\"hljs-comment\">// if error: ctx.body = { error }</span>\n  ctx.body = { user }\n}\n\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@typedef <span class=\"hljs-type\">{import('../types').User}</span> </span>_nodetools.User\n */</span></code></pre>\n\n<p>The fact that we import types, provides us with the desired experience: we can invoke auto-completions on the created object:</p>\n\n<p>\n  <img class=\"b-t b-bk b-vk\" alt=\"name auto-completion\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='600' height='405'/%3E\" data-io>\n  <noscript><img class=\"b-t b-bk b-vk\" alt=\"name auto-completion\" src=\"/nodetools/pages/web/img/name.gif\"></noscript>\n</p>\n\n<p>For frontend, it is the same, as we annotate the <span class=\"tm\">state.user</span> object with the user type. This not only prevents the compiler from mangling destructured property names of the received object, but also allows us to access the hints.</p>\n\n<p>\n  <img class=\"b-t b-bk b-vk\" alt=\"user type hint in front-end\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='600' height='270'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-t b-bk b-vk\" alt=\"user type hint in front-end\" src=\"/nodetools/pages/web/img/user.gif\">\n  </noscript>\n</p>\n\n<p><em>TypeScript</em> is said to be JavaScript that scales, that is great for large-scale app development, exactly because it provides convenient way to work with types for back-end and front-end. But I don't believe that using a new language and a proprietary typings infrastructure, is a solution. <em>NodeTools</em> is a stack for pure JS development, and we've achieved the same result with JSDoc annotations. Keeping types in a separate place and then compiling them, and importing from places we need, works just as well and allows to stay <strong>independent</strong>.</p>\n\n<p>The types for <em>VSCode</em> are generated into the <span class=\"tm\">types/index.js</span> file:</p>\n\n<pre><code class=\"js hljs\"><span class=\"hljs-keyword\">export</span> {}\n\n<span class=\"hljs-comment\">/* typal types/index.xml namespace */</span>\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@typedef <span class=\"hljs-type\">{_nodetools.ServerResponse}</span> </span>ServerResponse `Ôº†record`\n * <span class=\"hljs-doctag\">@typedef <span class=\"hljs-type\">{Object}</span> </span>_nodetools.ServerResponse `Ôº†record`\n * <span class=\"hljs-doctag\">@prop <span class=\"hljs-type\">{!_nodetools.User}</span> </span>[user] The user object.\n * <span class=\"hljs-doctag\">@prop <span class=\"hljs-type\">{string}</span> </span>error The server-side error.\n * <span class=\"hljs-doctag\">@typedef <span class=\"hljs-type\">{_nodetools.User}</span> </span>User `Ôº†record`\n * <span class=\"hljs-doctag\">@typedef <span class=\"hljs-type\">{Object}</span> </span>_nodetools.User `Ôº†record`\n * <span class=\"hljs-doctag\">@prop <span class=\"hljs-type\">{string}</span> </span>name The name of the user.\n * <span class=\"hljs-doctag\">@prop <span class=\"hljs-type\">{string}</span> </span>login The unique login of the user.\n */</span>\n</code></pre>\n\n<p>We added <span class=\"tm\">export {}</span> at the top to make it possible to import types from other files, which is otherwise impossible. The <span class=\"tm\">namespace</span> argument in the <span class=\"tm2\">typal</span> marker is needed to preserve namespaces, which a convention in <em>NodeTools</em> since we need to match the externs' namespace. You can omit namespace altogether for simple applications but it's just how I do things.</p>\n\n<pre><code class=\"js hljs\"><span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@fileoverview</span>\n * <span class=\"hljs-doctag\">@externs</span>\n */</span>\n\n<span class=\"hljs-comment\">/* typal types/index.xml externs */</span>\n<span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@const </span>*/</span>\n<span class=\"hljs-keyword\">var</span> _nodetools = {}\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@record</span>\n */</span>\n_nodetools.ServerResponse\n<span class=\"hljs-comment\">/**\n * The user object.\n * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">{(!_nodetools.User)|undefined}</span></span>\n */</span>\n_nodetools.ServerResponse.prototype.user\n<span class=\"hljs-comment\">/**\n * The server-side error.\n * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">{string}</span></span>\n */</span>\n_nodetools.ServerResponse.prototype.error\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@record</span>\n */</span>\n_nodetools.User\n<span class=\"hljs-comment\">/**\n * The name of the user.\n * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">{string}</span></span>\n */</span>\n_nodetools.User.prototype.name\n<span class=\"hljs-comment\">/**\n * The unique login of the user.\n * <span class=\"hljs-doctag\">@type <span class=\"hljs-type\">{string}</span></span>\n */</span>\n_nodetools.User.prototype.login\n</code></pre>\n\n<p>Any time we updates types.xml file, we'll run <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>d</span></span></span> command to recompile types and externs. By the time <em>Node Tools 2</em> is released, we'll have a watch mode also, but for now we need to make use of scripts manually:</p>\n\n<pre><code class=\"json hljs\">{\n  <span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"nodetools-web\"</span>,\n  <span class=\"hljs-attr\">\"scripts\"</span>: {\n    <span class=\"hljs-attr\">\"start\"</span>: <span class=\"hljs-string\">\"alanode index.jsx\"</span>,\n    <span class=\"hljs-attr\">\"closure\"</span>: <span class=\"hljs-string\">\"CLOSURE=1 yarn start\"</span>,\n    <span class=\"hljs-attr\">\"web\"</span>: <span class=\"hljs-string\">\"depack frontend -o docs -a -H -E -i --externs types/externs.js\"</span>,\n    <span class=\"hljs-attr\">\"d\"</span>: <span class=\"hljs-string\">\"yarn-s d1 externs\"</span>,\n    <span class=\"hljs-attr\">\"d1\"</span>: <span class=\"hljs-string\">\"typal types/index.js -u\"</span>,\n    <span class=\"hljs-attr\">\"externs\"</span>: <span class=\"hljs-string\">\"typal types/externs.js -e\"</span>\n  },\n  <span class=\"hljs-attr\">\"license\"</span>: <span class=\"hljs-string\">\"AGPL-3.0\"</span>,\n  <span class=\"hljs-attr\">\"devDependencies\"</span>: {\n    <span class=\"hljs-attr\">\"@externs/preact\"</span>: <span class=\"hljs-string\">\"^1.2.9\"</span>,\n    <span class=\"hljs-attr\">\"depack\"</span>: <span class=\"hljs-string\">\"^1.1.1\"</span>,\n    <span class=\"hljs-attr\">\"preact\"</span>: <span class=\"hljs-string\">\"8.5.3\"</span>,\n    <span class=\"hljs-attr\">\"unfetch\"</span>: <span class=\"hljs-string\">\"^4.1.0\"</span>,\n    <span class=\"hljs-attr\">\"yarn-s\"</span>: <span class=\"hljs-string\">\"^1.2.3\"</span>\n  }\n}\n</code></pre>\n\n<p><em>Idio</em>'s frontend and server-side rendering only work with <em>Preact</em> 8 at the moment, without fragments support since that requires a small change to the parser. I've not had a reason to upgrade to <em>Preact</em> 10, but when there's time, I will do. The server is then started with <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>start</span></span></span> command.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='9'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/4.svg\"></noscript></a>\n</p>\n</div>\n\n<!-- </div> -->\n\n<div data-section id=\"accessing-server\">\n<h2>Accessing Server</h2>\n\n<p>We now can access our app from the browser:</p>\n\n<p class=\"b-kC\">\n  <img class=\"b-t b-bk b-vk\" alt=\"preview of the app\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='500' height='375'/%3E\" data-io>\n  <noscript><img class=\"b-t b-bk b-vk\" alt=\"preview of the app\" src=\"/nodetools/pages/web/img/chrome.gif\"></noscript>\n</p>\n\n<p>The component rendered correctly, and displayed data received from the server. If we check network requests, we can see how the <span class=\"tm\">frontend</span> middleware has transformed our <strong>index.jsx</strong> file:</p>\n\n<p>\n  <img class=\"b-t b-bk b-vk\" alt=\"devtools shows transpilation\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='770' height='528'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-t b-bk b-vk\" alt=\"devtools shows transpilation\" src=\"/nodetools/pages/web/img/devtools.gif\">\n  </noscript>\n</p>\n\n<p>The imports have been updated to point to the <span class=\"tm\">/node_modules/</span> path, rather than simple <span class=\"tm2\">package-name</span> notation. Moreover, the JSX syntax has been updated to invoke the <span class=\"tm\">h</span> pragma function from <em>Preact</em>. <em>Preact</em> is the default choice for frontend, but if you wanted to use <em>React</em>, you'd have to specify the <strong>pragma</strong> property in the <span class=\"tm\">frontend</span> config. There's no sourcemaps, but line numbers have been preserved so you can still step through in the debugger.</p>\n\n<p>The style has been updated into a JS file that calls <span class=\"tm2\">__$styleInject</span> when imported:</p>\n\n<pre id=\"ccdbf1\"><code class=\"javascript hljs\">function __$styleInject(css = '') {\n  const head = document.head\n  const style = document.createElement('style')\n  style.type = 'text/css'\n  if (style.styleSheet){\n    style.styleSheet.cssText = css\n  } else {\n    style.appendChild(document.createTextNode(css))\n  }\n  head.appendChild(style)\n}\nconst style = `.Error {\n  color: red;\n}\n.UserName {\n  color: darkcyan;\n}`\n__$styleInject(style)</code></pre>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='10'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/5.svg\"></noscript></a>\n</p>\n</div>\n\n<div data-section id=\"compilation\">\n<h2>Compilation</h2>\n\n<p>After we made sure that the app is working correctly, I want to compile it with <em>Closure</em>. <em>Depack</em> supports JSX apps, and will transpile them prior to compilation into the <strong>depack-temp</strong> folder.</p>\n\n<p>I'll call the <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>web</span></span></span> script from <strong>package.json</strong> &mdash; <span class=\"tm2\">depack frontend -o docs -a -H -E -i --externs types/externs.js</span>. The arguments mean:</p>\n\n<ul>\n  <li><strong>frontend</strong>, the path to the entry file, short for <strong>frontend/index.jsx</strong>;</li>\n  <li><strong>-o docs</strong>, the output path (either full file, or just dir, in which case the basename of the input will be used);</li>\n  <li><strong>-a</strong>, advanced compilation, one of the best features of the compiler that minifies the source.</li>\n  <li><strong>-H</strong>, tells <em>Depack</em> to add Preact's pragma.</li>\n  <li><strong>-E</strong>, instructs <em>Depack</em> to use <span class=\"tm2\">preact</span> from externs, treating it as a library that is already given in the scope. During the process, <em>Depack</em> will monkey-patch <span class=\"tm\">node_modules/preact</span> and restore it at the end. This is needed since some 3rd party packages may reference <span class=\"tm2\">preact</span> and we don't transpile those.</li>\n  <li><strong>-i</strong>, produces an IIFE function, to prevent polluting and conflicts with the global scope.</li>\n  <li><strong>--externs types/externs.js</strong>*, those are the generated externs to notify the compiler of the types information.</li>\n</ul>\n\n<p>The bundle and its source maps will be written to the <span class=\"tm\">docs</span> folder.</p>\n\n<p>\n  <img class=\"b-t b-bk b-vk\" alt=\"compilation process\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='827' height='649'/%3E\" data-io>\n  <noscript><img class=\"b-t b-bk b-vk\" alt=\"compilation process\" src=\"/nodetools/pages/web/img/2.gif\"></noscript>\n</p>\n\n<p>If there were some problems with types that <em>Closure</em> could pick up, they will be shown in the output. We saved our temp files in the <span class=\"tm\">depack-temp</span>, so it won't be possible to jump to the error since the <strong>temp</strong> folder is deleted by the end of the process (we'll update <em>Depack</em> to point to the real src in the next version). For example, the warning we get here, is that the second argument to fetch is compulsory, which is not true and it's a problem with how <span class=\"tm2\">unfetch</span> was annotated rather than our code.</p>\n\n<p>To test whether bundling was successful, we will start the server with <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>closure</span></span></span> command that sets the <span class=\"tm\">CLOSURE=1</span> environment variable, which is then read by the server so that the our app can be served from <strong>docs/index.js</strong> rather than <strong>frontend/index.jsx</strong> which was used only for development.</p>\n\n<p>When we access the server again, we are served with the compiled JS bundle, that also includes our CSS as a string.</p>\n\n<p>\n  <img class=\"b-t b-bk b-vk\" alt=\"compiled js is served\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='770' height='528'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-t b-bk b-vk\" alt=\"compiled js is served\" src=\"/nodetools/pages/web/img/dev-index.gif\">\n  </noscript>\n</p>\n\n<p>That's all folks we just created a simple <em>Preact</em> application using a front-end middleware from <em>Idio</em> and compiled it using <em>Closure Compiler</em>. We also typed both front-end and back-end with JSDoc so that we could use pure JavaScript. In addition, types that we produced, could be embedded into documentation of our package using <em>Documentary</em> from <em>NodeTools</em>, however I'll skip talking about it here.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='10'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/6.svg\"></noscript></a>\n</p>\n</div>\n\n<div data-section id=\"additional-points\">\n<h2>Additional Points</h2>\n\n<p>There are a few things worth mentioning at the end.</p>\n\n<div data-section id=\"external-jsx\">\n<h3>External JSX</h3>\n\n<p><em>Depack</em> doesn't transpile JSX in published packages, therefore they need to make sure their published code is transpiled into standard JavaScript with <span class=\"tm\">h</span> pragma calls. This can be done with <em>√ÄLaMode</em>. For example, the <span class=\"tm2\">@depack/form</span> package is a library to create Bootstrap forms that was written in JSX, e.g.,</p>\n\n<pre id=\"ccdbf2\"><code class=\"javascript hljs\">import { Component } from 'preact'\n\nexport default class Form extends Component {\n  // ... component code\n  render(props) {\n    const { children, formRef, onSubmit, onChange, ...prop } =\n      /** @type {!_depackForm.FormProps} */ (props)\n    return &lt;form ref={formRef} onSubmit={onSubmit} {...prop}&gt;\n      {children}\n    &lt;/form&gt;\n  }\n}</code></pre>\n\n<p>It is then transpiled into the <strong>build</strong> folder, however <span class=\"tm2\">imports</span> stay as imports, and don't become <span class=\"tm\">require</span> calls. If we were publishing back-end components, we'd also transpile <span class=\"tm2\">imports</span> but since Closure can understand them, we keep it.</p>\n\n<pre id=\"ccdbf3\"><code class=\"javascript hljs\">import { h } from 'preact'\nimport { Component } from 'preact'\n\nexport default class Form extends Component {\n  // ... component code\n  render(props) {\n    const { children, formRef, onSubmit, onChange, ...prop } =\n      /** @type {!_depackForm.FormProps} */ (props)\n    return    h('form',{...prop,'ref':formRef, 'onSubmit':onSubmit},\n      children,\n    )\n  }\n}</code></pre>\n\n<p>However, because we want <em>Closure</em> to read the transpiled code, our <span class=\"tm2\">module</span> field should really point to the <strong>build</strong> dir (module takes precedence over main in <em>Depack</em>):</p>\n\n<pre id=\"cb9de\"><code class=\"json hljs\">{\n  \"main\": \"src/index.jsx\",\n  \"module\": \"build/index.js\"\n}</code></pre>\n\n<p>And the <span class=\"tm2\">main</span> will point to the source code, which is not really necessary, but I think <span class=\"tm\">frontend</span> at the moment still reads the <span class=\"tm\">main</span> field, and will be able to transpile the source code (I now realise this is redundant, and <span class=\"tm\">main</span> should probably become require-transpiled code for server-side rendering üëç).</p>\n\n<p>Another question is how to test front-ends with <em>NodeTools</em>. As I said, I'm only working on the next version right now, but there is are a few strategies for testing, that is, server-side rendering of components, and also using headless chrome to render components in Chrome, and then get the snapshot of the DOM and send it back to the server for comparison against snapshots.</p>\n\n</div>\n\n<div data-section id=\"ssr-testing\">\n<h3>SSR Testing</h3>\n\n<p>For basic testing of components written in <em>Preact</em>, you can take advantage of the <a href=\"https://github.com/dpck/context\"><em>JSXContext</em></a> that can transform an input string into a JSX VNode, that can then be rendered. Using this method, you can declare your components using simple HTML from masks, and compare rendered result to the expected output.</p>\n\n<pre id=\"ccdbf4\"><code class=\"javascript hljs\">// test/mask/default.js\n\nimport makeTestSuite from '@zoroaster/mask'\nimport JSXContext from '@depack/context'\nimport Form, * as Form2 from '../../src'\n\nexport default makeTestSuite('test/result/default', {\n  /**\n   * @param {JSXContext} context\n   */\n  getResults({ getVNode, render }) {\n    const vnode = getVNode(this.input, {\n      Form, ...Form2,\n    })\n    const res = render(vnode, {\n      pretty: true,\n    })\n    return `(${res})`\n  }\n})</code></pre>\n\n<p>The mask result in JSX format will then use a preamble to import components for syntax highlighting and auto-completions, and define inputs as JSX methods and outputs as HTML code. I've surrounded each block with <span class=\"tm\">()</span> so that there's no syntax errors underlined with red in the file. Mask results are used only to define inputs/outputs, so despite the fact that the format of this file is JSX, it's only so to enable syntax highlighting.</p>\n\n<pre id=\"ccdbf5\"><code class=\"javascript hljs\">// test/result/default/form-group.jsx\n\nimport { TextArea, Select, Form, FormGroup, Input } from '../../src'\n\n// default FormGroup\n(&lt;FormGroup label=\"test\" help=\"ok\"&gt;\n  &lt;Input placeholder=\"test\"/&gt;\n&lt;/FormGroup&gt;)\n\n/* expected */\n(&lt;div class=\"form-group\"&gt;\n  &lt;label for=\"i70984\"&gt;test&lt;/label&gt;\n  &lt;input placeholder=\"test\"\n    class=\"form-control\" type=\"text\"\n    aria-describedby=\"hi70984\" id=\"i70984\" /&gt;\n  &lt;small id=\"hi70984\"\n    class=\"form-text text-muted\"&gt;ok\n  &lt;/small&gt;\n&lt;/div&gt;)\n/**/\n\n// details FormGroup\n(&lt;FormGroup label=\"test\" help=\"ok\" details&gt;\n  &lt;Input placeholder=\"test\"/&gt;\n&lt;/FormGroup&gt;)\n\n/* expected */\n(&lt;details class=\"form-group\"&gt;\n  &lt;summary&gt;\n    &lt;label for=\"i70984\"&gt;test&lt;/label&gt;\n  &lt;/summary&gt;\n  &lt;input placeholder=\"test\"\n    class=\"form-control\" type=\"text\"\n    aria-describedby=\"hi70984\" id=\"i70984\" /&gt;\n  &lt;small id=\"hi70984\"\n    class=\"form-text text-muted\"&gt;ok\n  &lt;/small&gt;\n&lt;/details&gt;)\n/**/</code></pre>\n\n</div>\n\n<div data-section id=\"headless-chrome\">\n<h3>Headless Chrome</h3>\n\n<p>The second strategy, is to spawn a headless browser as a background process, setup a server that will return some HTML with script tags that invoke JavaScript to render certain components on elements. Each test will open a new page, with slightly different setup routine, wait for JS to execute, and send the element's outer HTML back to the server. We'll use a <em>RemoteChrome</em> context to connect to the browser:</p>\n\n<pre id=\"ccdbf6\"><code class=\"javascript hljs\">import CDP from 'chrome-remote-interface'\nimport { c, b } from 'erte'\n\nexport default class RemoteChrome {\n  async _init() {\n    let client\n    client = await CDP({\n      host: '127.0.0.1',\n      port: '9222',\n    })\n    const { Network, Page, Runtime } = client\n    await Network.enable()\n    await Page.enable()\n    this.client = client\n    this._Page = Page\n    this._Runtime = Runtime\n    this.Network = Network\n    console.log('[%s]: %s', c('RemoteChrome', 'red'), b('Page enabled', 'green'))\n  }\n  static get _timeout() {\n    return 10000\n  }\n  /**\n   * The enabled page, write types for that\n   */\n  get Page() {\n    return this._Page\n  }\n  /**\n   * The runtime.\n   */\n  get Runtime() {\n    return this._Runtime\n  }\n  async _destroy() {\n    if (this.client) {\n      await this.client.close()\n    }\n  }\n}</code></pre>\n\n<p>We'll also need the <em>Idio</em> context that will start a server to return HTML code.</p>\n\n<pre id=\"ccdbf7\"><code class=\"javascript hljs\">import idio from '@idio/idio'\nimport frontend from '@idio/frontend'\nimport render from '@depack/render'\nimport jsx from '@a-la/jsx'\n\nexport default class IdioContext {\n  /**\n   * The context will start a server and serve the code given\n   * @param {import('@idio/idio').MiddlewareConfig} config\n   */\n  async start(config = {}, port = null) {\n    const { input, pre = '', ...conf } = config\n    const inv = jsx(input, {\n      quoteProps: 'dom',\n    })\n    const pree = jsx(pre, {\n      quoteProps: 'dom',\n    })\n    const { app, url } = await idio({\n      frontend: {\n        async middlewareConstructor() {\n          const f = await frontend({\n            directory: ['src', 'test/context/idio', 'build'],\n          })\n          return f\n        },\n        use: true,\n      },\n      async serveJSX(ctx) {\n        ctx.body = render(&lt;html&gt;\n          &lt;head&gt;\n            &lt;meta charset=\"utf-8\"/&gt;\n            &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, shrink-to-fit=no\"/&gt;\n\n            &lt;link rel=\"stylesheet\" href=\"https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css\" integrity=\"sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T\" crossOrigin=\"anonymous\"/&gt;\n            &lt;title&gt;Hello, world!&lt;/title&gt;\n          &lt;/head&gt;\n          &lt;script type=\"module\" src=\"test/context/idio/math-random.js\" /&gt;\n          &lt;script type=\"module\" src=\"test/context/idio/format.js\" /&gt;\n          &lt;script type=\"module\" dangerouslySetInnerHTML={{\n            __html: `import { h, render, Component } from '/node_modules/preact/src/preact.js'\n/**/ import Form, { FormGroup, Input, TextArea, Select } from '/${process.env.ALAMODE_ENV=='test-build' ? 'build' : 'src'}/'\n${pree}\nconst inv = ${inv}\nrender(inv, document.body)\n`,\n          }}&gt;\n          &lt;/script&gt;\n        &lt;/html&gt;, { addDoctype: 1, pretty: 1 })\n      },\n      ...conf,\n\n    }, { port })\n    this.app = app\n    this.url = url\n    return this.url\n  }\n  async _destroy() {\n    if (this.app)\n      await this.app.destroy()\n  }\n}</code></pre>\n\n<p>This context includes some utilities on the page, for example, <a\n  href=\"https://github.com/dpck/form/blob/aa9d5137ca5535e46d8c71056c03e81ab2ff4da7/test/context/idio/format.js\">\n  for formatting</a>, and calls Preact's render method on the invocation passed from tests. The mask setup is then the following:</p>\n\n<pre id=\"ccdbf8\"><code class=\"javascript hljs\">import makeTestSuite from '@zoroaster/mask'\nimport { equal } from '@zoroaster/assert'\nimport IdioContext from '../context/Idio'\nimport RemoteChrome from '../context/RemoteChrome'\n\nexport const Chrome = makeTestSuite('test/result/chrome.jsx', {\n  /**\n   * @param {RemoteChrome} i\n   * @param {IdioContext} i\n   */\n  async getResults({ Page, Runtime, client }, { start }) {\n    const { action, pre } = this\n    const url = await start({\n      pre,\n      input: this.input,\n    })\n\n    await Page.navigate({ url })\n    await Page.loadEventFired()\n    let actionValue\n    if (action) {\n      const s = await Runtime.evaluate({ expression: action,\n        awaitPromise: true })\n      handleError(s)\n      if (s.result) actionValue = s.result.value\n    }\n    const res = await Runtime.evaluate({ expression: 'window.idio.format(document.querySelector(\\'html body\\'), 0).innerHTML.trim()' })\n    // IF A TEST IS TIMING OUT, DEBUG MANUALLY:\n    // console.log('', url)\n    // await new Promise((r) =&gt; setTimeout(r, 1000000))\n    const { result: { value } } = res\n    const v = value.replace(/(&lt;input[\\s\\S]*?)&gt;/g, (m, i) =&gt; {\n      return `${i} /&gt;`\n    })\n    return { actionValue, actual: `(${v})` }\n  },\n  mapActual({ actual }) {\n    return actual\n  },\n  assertResults({ actionValue }, { actionValue: av }) {\n    if (av) equal(`'${actionValue}'`, av)\n  },\n  context: IdioContext,\n  persistentContext: [RemoteChrome],\n})</code></pre>\n\n<p>The <span class=\"tm2\">action</span> and <span class=\"tm2\">pre</span> are properties of the mask result which wil be shown next. We start a server by passing these properties, and make the browser navigate to that prepared page, waiting until it's fully loaded. We then evaluate some JS from <span class=\"tm2\">action</span> if it was passed, and grab the <span class=\"tm\">body</span> element from the DOM, while also formatting it using the <span class=\"tm2\">format</span> utility. We then return the result of the action (if it was given), and the HTML. The HTML is compared against the expected output using simple string comparison via mask result, while the action value is asserted on using the standard <span class=\"tm\">equal</span> method from the assertion library in the mask itself.</p>\n\n<p>Example mask result:</p>\n\n<pre id=\"ccdbf9\"><code class=\"javascript hljs\">/* eslint-env browser */\nimport { Component } from 'preact'\nimport { TextArea, Select, Form, FormGroup, Input } from '../../src'\n\n// Form\n(&lt;Form&gt;&lt;/Form&gt;)\n\n/* expected */\n(&lt;form&gt;&lt;/form&gt;)\n/**/\n\n// Reset\n(&lt;Form&gt;&lt;App /&gt;&lt;/Form&gt;)\n\n/* pre */\nclass App extends Component {\n  constructor() {\n    super()\n    this.state = { value: 'hello-world' }\n  }\n  render() {\n    const { value } = this.state\n    return (&lt;Input required type=\"text\" value={value} onClick={() =&gt; {\n      this.setState({ value: 'new value' })\n    }}/&gt;)\n  }\n}\nasync function clickInput() {\n  const input = document.querySelector('input')\n  input.click()\n  await new Promise(r =&gt; setTimeout(r, 1))\n  return input.value\n}\nwindow.clickInput = clickInput\n/**/\n\n/* action */\nclickInput()\n/**/\n/* actionValue */\n'new value'\n/**/\n\n/* expected */\n(&lt;form&gt;\n  &lt;input required=\"\" class=\"form-control\" type=\"text\" /&gt;\n&lt;/form&gt;)\n/**/</code></pre>\n\n<p>The first test is pretty simple rendering of an empty form element. The second test creates a component, and makes the <span class=\"tm\">clickInput</span> method available to the window scope. When the page is loaded, via the action we click the input, which changes the state of the Form component, triggering and update of the input value because of internal logic. Because this process is async, we had to wait 1ms in the <span class=\"tm\">clickInput</span> method, which then grabs the new value of the input, and returns it for assertion in the mask. This way, we've tested interaction with the component from a real browser. The rendered code is also compared to the expected one.</p>\n\n<p>There are a few more examples that you can use for reference:</p>\n\n<ul>\n  <li><span class=\"tm2\">Exif</span> <a href=\"https://github.com/demimonde/exif/tree/master/test\">package</a> that reads metadata of files from a headless browser (the testing API is available via <span class=\"tm2\">@contexts/chrome</span> now). It will also start the server, prepare test pages from the mask, navigate to them, execute <span class=\"tm\">window.test</span> method and return the result.</li>\n  <li><span class=\"tm2\">exif2css</span> <a href=\"https://github.com/demimonde/exif2css/tree/master/test\">package</a> that puts an image on a page, and uses its metadata EXIF information to rotate into correct position with CSS. Then, a screenshot of the page is taken using the same <span class=\"tm2\">@contexts/chrome</span> context, and compared against the gold standard from fixtures using <span class=\"tm2\">node-resemble-js</span> package that highlights the differences. The threshold for passing tests is 99%, so that if the library became broken, the similarity measure would fall below that.<p><img class=\"b-vk b-t\" alt=\"image difference testing\" data-io>\n<noscript><img class=\"b-vk b-t\" alt=\"image difference testing\" src=\"/nodetools/pages/web/img/1_diff.png\"></noscript></p></li>\n</ul>\n\n<p>I hope these examples can provide starting points for implementing your own testing routines. <em>NodeTools 2</em> will definitely standardise browser testing.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='53' height='12'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/7.svg\"></noscript></a>\n</p>\n</div>\n\n<div data-section id=\"comments\">\n<h2>Comments</h2>\n\n  <div id=\"c8b27\">Loading comments...</div>\n\n</div>",
  "file": "web",
  "postAjax": "(function imgPostAjax() {\n  /* eslint-env browser */\n  window['IO']()\n  window['WEBP']()\n})()"
}