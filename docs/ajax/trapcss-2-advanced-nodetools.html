{
  "title": "TrapCSS 2: Advanced NodeTools",
  "content": "\n\n<div data-section id=\"trapcss-2\">\n<h1>TrapCSS2: Advanced NodeTools</h1>\n\n<p>In the previous part, we looked at the first steps in creating a new package with <em>NodeTools</em> stack. During the initialisation process with <span class=\"tm\">mnp</span>, we were asked some questions like if we wanted to compile the package, if a binary should be added and whether <em>GitHub</em> wiki should be created. We answered yes to all three questions, so let's get on with the second part of the tutorial.</p>\n\n<p>\n  <img class=\"ImageHolder b-vk b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\" alt=\"trapcss2: advanced nodetools tutorial (car splash)\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1000' height='668'/%3E\">\n  <noscript>\n    <picture>\n      <source\n        srcset=\"/nodetools/pages/trapcss2/img/trapcss2-768.webp 768w,/nodetools/pages/trapcss2/img/trapcss2-576.webp 576w,/nodetools/pages/trapcss2/img/trapcss2-319.webp 319w,/nodetools/pages/trapcss2/img/trapcss2-1000.webp 1000w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\"\n        type=\"image/webp\">\n      <img class=\"b-vk b-t\" onLoad=\"webploaded(this)\" alt=\"trapcss2: advanced nodetools tutorial (car splash)\" src=\"/nodetools/pages/trapcss2/img/trapcss2-768.jpg\" srcset=\"/nodetools/pages/trapcss2/img/trapcss2-768.jpg 768w,/nodetools/pages/trapcss2/img/trapcss2-576.jpg 576w,/nodetools/pages/trapcss2/img/trapcss2-319.jpg 319w,/nodetools/pages/trapcss2/img/trapcss2-1000.jpg 1000w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\">\n    </picture>\n  </noscript>\n</p>\n\n<p>At the end, we'll also look how to incorporate <em>TrapCSS</em> into another package with <em>StdLib</em> strategy: we'll compile a file called <strong>stdlib.js</strong> for a static website generator <em>Splendid</em> that will statically link to <span class=\"tm\">trapcss</span>, meaning that they will be distributed together. This will allow to reduce the total number of dependencies in the target package and make it more appealing to users.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='15'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/0.svg\"></noscript></a>\n</p>\n</div>\n\n<div data-section id=\"welcome-closure\">\n<h2>Welcome Closure</h2>\n\n<p>Prior to <em>NodeTools</em>, the industry standard was to simply transpile source code with <em>Babel</em>, or not use modules at all and avoid transpilation step altogether. The first option is not good because <em>Babel</em> is a package with 250+ dependencies that jam our <span class=\"tm2\">node_modules</span>, and also because for years it's been disparaging professional software engineering values that are in core of <em>NodeTools</em>, such as respect for <em>JSDoc</em>, as can be read in the <a href=\"/nodetools/babel-when-open-source-is-not-free-sofware.html\">\n   Babel: When Open Source Is Not Free Sofware</a> article. The second option is not applicable either as I believe in embracing innovation and keeping up with the newest technological advances to be able to be productive and remain competent and competitive.</p>\n\n<p>Because <span class=\"tm\">NearForm</span>, the <a href=\"https://www.nearform.com/community/\">largest contributor</a> to Node.JS with labour resource of over 100 people, extorted back-end engineers into using <em>Babel</em> by not implementing ECMA modules since 2015, the actual state of art of modern package making is pretty sad. Those working on <em>Babel</em> took the advantage of that forced downloads count to call their buggy product a compiler, which is not true. It's popular only because people had no choice rather because it's exceptional in any way. A compiler is a sophisticated piece of software so there must be something special about a program to be called this name (rather than a transpiler). <em>Closure Compiler</em> is software that will check types and perform advanced passes like peep-hole optimisation and function call folding, therefore it really deserves this title.</p>\n\n<p>Up until <em>NodeTools</em>, there were 4 ways to create <strong>Node.JS</strong> packages:</p>\n\n<ol>\n  <li><strong>old-school</strong>, by keeping <span class=\"tm\">module.exports</span> and not taking advantage of modules' syntax which is one of the best features of JavaScript;</li>\n  <li><strong>alternative</strong>, that included an additional bundle up step, with such software as rollup and webpack;</li>\n  <li><strong>TypeScript</strong>, which is a corporate paradigm that has swept the world due to the lack of professional tools that could compete with it to provide good routines for working with types;</li>\n  <li><strong>Babel</strong>, the mass-mentality industry pattern that has no respect for its users, whose authors self-proclaimed themselves leaders of the sector while failing miserably to meet essential requirements for a transpiler.</li>\n</ol>\n\n<p><em>NodeTools</em> is a new, <strong>indie</strong> replacement to all these methods that allows to leave them behind and focus on JS coding. We provide the most light-weight, pure <em>JavaScript</em> solution that would allow to develop professional packages and keep independent from 3rd party software that dictates how you should work and what <em>your</em> code should look like. The developer and her freedom is our top priority. For example, there's literally no config for compiling you packages, and all annotations are based on the open JSDoc standard. You can still choose the language output (such as ECMA2015-2019) and control other options like pretty printing via CLI arguments. <em>NodeTools</em> is the only methodology that starts to use <em>Closure Compiler</em> for packages, and it takes Node.JS software development to the next level.</p>\n\n<div data-section id=\"installation\">\n<h3>Installation</h3>\n\n<p><em>Closure Compiler</em> is developed by Google. It's used for mission-critical internal projects, that are not based on TypeScript. It's a Java program of the size of 10MB that can be installed once on the system, and using advanced optimisations, can put the source code, as well as all liked dependencies into a single executable file. In other words, it provides static linking for libraries into our generated code. Type checking now becomes the final stage of the development process that provides insight into small inaccuracies in our types, instead of forcing us to think in terms of types, like in <em>TypeScript</em>.</p>\n\n<p>To use the compiler, you'll need Java on your machine. If you're working on Windows, you can just install it from the official website and it'll be working fine. On a Mac, I had to add the following line to my <span class=\"tm2\">~/.bash_profile</span>.</p>\n\n<pre id=\"c414d3\"><code class=\"bash hljs\">export JAVA_HOME=/Library/Internet\\ Plug-Ins\\JavaAppletPlugin.plugin/Contents/Home</code></pre>\n\n<p>If you're using <strong>zsh</strong>, also add <span class=\"tm2\">source ~/.bash_profile</span> to your <strong>~/.zshrc</strong>. Then we're going to install <span class=\"tm\">google-closure-compiler-java</span> into the home folder:</p>\n\n<pre id=\"c414d\"><code class=\"bash hljs\">cd ~\nyarn|npm init # we want to save deps in package.json\nyarn add google-closure-compiler-java</code></pre>\n\n<p>\nYour distribution will be installed in the <strong>~/node_modules</strong> directory.\nOn top of the compiler itself, the actual package that executes the process, is called <em>Depack</em>. It's made possible to compile Node.JS package for the first time, since it wasn't possible before as when trying to compile back-end software with Closure, it would throw errors since it couldn't recognise internal Node API, such as <span class=\"tm\">fs</span>, <span class=\"tm\">stream</span>, <em>etc</em>. <em>Depack</em> fixes this by creating mock folders in your <span class=\"tm\">node_modules</span>,\nsuch as <strong>node_modules/fs/index.js</strong>,\n<strong>node_modules/fs/package.json</strong> that simply destructure the global API annotated via externs to enable type checking. We've implemented the externs for Node 8 API, which should also work with later versions.\n</p>\n\n<pre id=\"ccdbf\"><code class=\"javascript hljs\">// node_modules/child_process/index.js\n/* a mock of child process built-in */\n\nexport default child_process\nexport const {\n  ChildProcess,\n  exec,\n  execFile,\n  execFileSync,\n  execSync,\n  fork,\n  spawn,\n  spawnSync,\n} = child_process</code></pre>\n\n<pre id=\"ccdbf1\"><code class=\"javascript hljs\">// node_modules/child_process/package.json\n{\n  \"name\": \"child_process\",\n  \"main\": \"index.js\"\n}</code></pre>\n\n<p>You can use nightly versions of the compiler, if you want, by looking up the last version with <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span>info</span> <span>google-closure-compiler-java</span></span></span> and setting the exact version, e.g., <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-cmd\">i</span><span class=\"yarn-cmd\">add</span> <span>google-closure-compiler-java@20200201.0.0-nightly</span></span></span>. This can help if there are occasional bugs in the compiler, e.g., the January 2020 version has broken destructuring, so you need to use the nightly build like the one I've just mentioned. There's a list of bugs in the compiler in the <a href=\"https://github.com/dpck/depack/wiki/Bugs\"><em>Depack</em> wiki</a>.</p>\n\n<p><em>Closure</em> is written in Java. You can fork <a href=\"https://github.com/google/closure-compiler\">their project</a> and study how it works. There's a lot of useful information on the <a href=\"https://github.com/google/closure-compiler/wiki\">Wiki</a>, especially in the types section. It might seem complex at first, but I managed to fix certain issues with PRs by only studying the source code for a few days. A compiler is based on AST passes, where you can manipulate nodes. There's also a JSDoc parser, and an inner project for JS source map consumption/generation. When you make a change, you build the compiler locally. Then you can set the <span class=\"tm\">GOOGLE_CLOSURE_COMPILER</span> env variable with the path to your target JAR, which will then be used by <em>NodeTools</em>.</p>\n\n<!-- end installation -->\n</div>\n\n<div data-section id=\"advantages\">\n<h3>Advantages</h3>\n\n<p>Some might say that we're still tied up to the compiler, but it's much better than Babel and TypeScript, because:</p>\n\n<ul>\n  <li>You don't need to install 250 dependencies just for your modules' syntax via <em>Babel</em>.</li>\n  <li>The bin size is 10mb instead of 50mb of <span class=\"tm\">TypeScript</span>.</li>\n  <li>You can statically link packages like in proper software engineering.</li>\n  <li>Compiler will produce type hints for you that are useful to polish your programs, but don't lock you into a completely different language which TS is.</li>\n  <li>It's meant for pure JavaScript development which is great.</li>\n  <li>Its advanced optimisation obfuscates code so that you can send it to your clients with a bit more security for your intellectual property.</li>\n  <li>You can compile complex back-end applications into a single JS file, for example, we created <a href=\"https://github.com/idiocc/idio\">Idio</a> which is a Koa server with essential middleware that only has 2 dependencies (<span class=\"tm\">mime-db</span> and <span class=\"tm\">text-decoding</span> which are databases for processing encoded data). Without compilation, <span class=\"tm2\">Idio</span> would have to download around 130 external dependencies.</li>\n  <li>It's maintained by <em>Google</em> themselves by top-level software engineers who know compiler theory, so you can rely on compilation results.</li>\n  <li>You don't have to compile, and simple transpilation is also possible without <em>Closure</em>.</li>\n  <li>You can keep the source code of your larger packages non-compiled, but instead compile only its dependencies into a file called <em>StdLib</em>.</li>\n</ul>\n\n<p>Additionally, another reason to learn about compiler and externs, is because the highest paid Software Engineering positions are for <span class=\"tm2\">Clojure</span> language, around $140k per year <a\n  href=\"https://insights.stackoverflow.com/survey/2019#technology-_-what-languages-are-associated-with-the-highest-salaries-worldwide\">\n  in the US</a>. When you're working on <em>Clojure</em> projects, you'll be writing your front-end in <em>ClojureScript</em>, that produces JavaScript compatible with <em>Closure Compiler</em>, so you'll need to understand how externs work. If you learn it via <em>NodeTools</em> today, you'll be prepared to become one of the highest-paid developers in the world if you decide to specialise in <em>Clojure</em> at some point.</p>\n\n<!-- end advantages -->\n</div>\n\n<div data-section id=\"web-bundling\">\n<h3>Web Bundling</h3>\n\n<p><em>NodeTools</em> is a holistic package development methodology. The compiler works together with all other tools, such as Typal, that allows to maintain a single source of truth for your types and generate externs for the compiler, Documentary that can embed and interlink such type information in documentation of packages including wikis, and <em>Zoroaster</em> that provides API to test forks as well as letting you test your target compiled code, instead of only source code, which is an absolute must when taking advantage of the advanced compilation mode.</p>\n\n<p>The primary realm of our stack is Node.JS package development, however with <em>Depack</em> you can also develop and compile <a href=\"https://github.com/art-deco/akashic.page\">web-bundles</a>, as there's also support for JSX syntax in <em>ÀLaMode</em>. It's based on regexes, but we've managed to create many nice widgets for the web with it. We'll be advertising the web stack features later on. We hope that the tools that we provide in only 10 <span class=\"tm\">node_modules</span> folders, will really allow to have a breath of fresh air in this stale-air environment where people adapt to paradigms, instead of using such powerful language as JavaScript to their maximum advantage.</p>\n\n<p>You can read about compiling front-end JavaScript code in the <a href=\"/nodetools/web-development-with-nodetools.html\">Web Development With NodeTools</a> article.</p>\n\n<!-- end web -->\n</div>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/1.svg\"></noscript></a>\n</p>\n</div>\n<!-- </div> -->\n\n<div data-section id=\"compiling-libraries\">\n<h2>Compiling Libraries</h2>\n\n<p>Let's get down to business. Advanced compilation means that our comments are going to be stripped off the source code, so that all type information is lost. It's possible to preserve all comments, however this is a new feature of the compiler, and will keep ALL comments which might be undesirable. We'll be compiling our API, so the strategy is the following:</p>\n\n<ol>\n  <li>to compile the source code into a file that exports API methods,</li>\n  <li>to import those API methods from another file that wraps them in JSDoc.</li>\n</ol>\n\n<p>\n  <img class=\"b-t\" alt=\"source compile and entry JS files\" data-io>\n  <noscript>\n    <img class=\"b-t\" alt=\"source compile and entry JS files\" src=\"/nodetools/pages/trapcss2/1-compile/img/source-compile-entry.gif\">\n  </noscript>\n</p>\n\n\n<div data-section id=\"templates\">\n<h3>Templates</h3>\n\n<p>The entry point for the compiler is <strong>src/depack.js</strong>, which imports the method from the source code and exports it via CommonJS standard. It also imports externs so that <em>Closure</em> will understand our types:</p>\n\n<pre id=\"ccdbf18\"><code class=\"javascript hljs\">import '../types/externs'\nimport trapcss from './'\n\n/*!\n * trapcss: Removes unused selectors from CSS files to achieve\n * maximum optimisation. Can be used as an API function or with CLI.\n *\n * Copyright (C) 2020  Art Deco Code Limited\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n */\n\n// export default {\nmodule.exports = {\n  '_trapcss': trapcss,\n}\n</code></pre>\n\n<p>This file also includes the APGL license that was selected when the package was bootstrapped. It uses the <span class=\"tm2\">/*!</span> notation to preserve the comment. If you chose MIT license, you'll also have a similar, but shorter notice. For other licenses, you'd have to add a comment manually. Also, for <em>AGPL</em>, we don't include the copyright on top of each file as I believe it's redundant, but feel free to do it your way.</p>\n\n<p>The entry to <em>Depack</em> imports our API, and assigns it to the <span class=\"tm\">modules.export</span> object. This will allow to access those methods (currently, just 1) from the <strong>compile</strong> dir. However, because we ran the <em>ÀLaMode</em> transpiler on the <strong>src</strong> folder, the <span class=\"tm\">module.exports =</span> got renamed into <span class=\"tm\">export default</span>, therefore just manually change it back now.</p>\n\n<p>We'll need to create a second file, called <span class=\"tm2\">template</span> in <strong>compile/template.js</strong>:</p>\n\n<pre id=\"ccdbf19\"><code class=\"javascript hljs\">const { _trapcss } = require('./trapcss')\n\n/**\n * @methodType {_trapcss.trapcss}\n */\nfunction trapcss(config) {\n  return _trapcss(config)\n}\n\nmodule.exports = trapcss\n\n/* typal types/index.xml namespace */\n</code></pre>\n\n<p>The template file is not meant for execution, but provides a blueprint for generation of our <span class=\"tm\">main</span> file (called main because of the main field in <strong>package.json</strong>). It has the <span class=\"tm\">@methodType {_trapcss.trapcss}</span> annotation, that declares the type of the function, so that its JSDoc can be expanded. It also contains the <span class=\"tm\">typal</span> marker at the bottom, so that we can embed our <em>Config</em> and <em>Return</em> types into the main file as well. To generate the real JavaScript file, we'll need to run the <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>d</span></span></span> command, that will run <span class=\"tm\">template</span> and <span class=\"tm\">d1</span> scripts in series. The template command is the following: <span class=\"tm2\">typal compile/template.js -T compile/index.js -t types/api.xml</span>:</p>\n\n<ul>\n  <li><strong>compile/template.js</strong>, is the path to the template file.</li>\n  <li><strong>-T compile/index.js</strong>, the path to the main file to be generated.</li>\n  <li><strong>-t types/api.xml</strong>, is the path to types that should be used. It could also point to the dir itself, however because we also included arguments.xml for our binary, that doesn't allow us to simply pass <span class=\"tm\">types</span>.</li>\n</ul>\n\n<p>The <span class=\"tm\">d1</span> command expands the typal marker in the <strong>index.js</strong> produced from the template &mdash; <span class=\"tm2\">typal compile/index.js types/index.js -u -t types/index.xml</span>:</p>\n\n<ul>\n  <li><strong>compile/index.js types/index.js</strong>, paths to files with <span class=\"tm2\">typal</span> markers that needs embedding typedefs.</li>\n  <li><strong>-u</strong>, tells <em>Typal</em> to use namespaces rather than simple type names.</li>\n  <li><strong>-t types/index.xml</strong>, the location of types, can be skipped.</li>\n</ul>\n\n<p>After the two commands are run, we'll have a production-ready entry file. Let's have a look at what is being produced as the <span class=\"tm\">main</span>:</p>\n\n<pre id=\"ccdbf20\"><code class=\"javascript hljs\">const { _trapcss } = require('./trapcss')\n\n/**\n * Parses the supplied HTML and CSS and removes\nunused selectors. Also removes empty CSS rules.\n * @param {_trapcss.Config} config Options for the program.\n * @param {string} config.html The input HTML.\n * @param {string} config.css The CSS to drop selectors from.\n * @param {boolean} [config.keepAlternate=false] Whether to keep the `@alternate` comment for\n * Closure Stylesheets. Default `false`.\n * @param {(sel: string) =&gt; boolean} [config.shouldDrop] Whether _TrapCSS_ should remove this selector.\n * The `shouldDrop` hook is called for every CSS selector\n * that could not be matched in the html. Return `false`\n * to retain the selector or `true` to drop it.\n * @return {_trapcss.Return}\n */\nfunction trapcss(config) {\n  return _trapcss(config)\n}\n\nmodule.exports = trapcss\n\n/* typal types/index.xml namespace */\n/**\n * @typedef {_trapcss.Config} Config `＠record` Options for the program.\n * @typedef {Object} _trapcss.Config `＠record` Options for the program.\n * @prop {string} html The input HTML.\n * @prop {string} css The CSS to drop selectors from.\n * @prop {boolean} [keepAlternate=false] Whether to keep the `@alternate` comment for\n * Closure Stylesheets. Default `false`.\n * @prop {(sel: string) =&gt; boolean} [shouldDrop] Whether _TrapCSS_ should remove this selector.\n * The `shouldDrop` hook is called for every CSS selector\n * that could not be matched in the html. Return `false`\n * to retain the selector or `true` to drop it.\n * @typedef {_trapcss.Return} Return `＠record` Return Type.\n * @typedef {Object} _trapcss.Return `＠record` Return Type.\n * @prop {string} css The dropped CSS.\n * @prop {!Set&lt;string&gt;} sels The used selectors.\n */\n</code></pre>\n\n<p>The entry file to our package contains an annotated function that wraps a method from the API. Since we decorated it with JSDoc, we'll be able to receive autocompletion hints on the config type when consuming the library from other packages. Our config is declared as a type at the bottom, but the <span class=\"tm\">config</span> property of the function is also expanded into individual <span class=\"tm2\">@param</span>s. This is to increase the visibility of the parameters, which will now appear on the function's description:</p>\n\n<p>\n  <img class=\"b-vk b-t\" alt=\"visibility of the config type for the method\" data-io>\n  <noscript>\n    <img class=\"b-vk b-t\" alt=\"visibility of the config type for the method\" src=\"/nodetools/pages/trapcss2/1-compile/img/vis.png\">\n  </noscript>\n</p>\n\n<p>This allows people to read the full description of the argument, without having to go through each individual property when expanding the config. Without this feature, the description doesn't give the full picture:</p>\n\n<p>\n  <img class=\"b-vk b-t\" alt=\"limited visibility of the config type\" data-io>\n  <noscript>\n    <img class=\"b-vk b-t\" alt=\"limited visibility of the config type\" src=\"/nodetools/pages/trapcss2/1-compile/img/vis2.png\">\n  </noscript>\n</p>\n\n<p>All typedefs should be embedded into the main file, which acts as a repository for types. This will make sure that types are always available. Do you remember how we imported the config type from <strong>types/index.js</strong> in the previous part?</p>\n\n<pre id=\"ccdbf2\"><code class=\"javascript hljs\">/**\n * @typedef {import('..').Config} _trapcss.Config\n * @typedef {import('..').Return} _trapcss.Return\n */</code></pre>\n\n<p>This is because the main file is treated as the go-to place for types. Using templates allows to treat source code independent from the API specification, and plug in the implementation into JSDoc-annotated shells for code. It's kind of similar to TypeScript that provides <span class=\"tm\">.d.ts</span> types, however in pure JavaScript. If you're exporting a class, you can also use the <span class=\"tm\">@constructor</span> tag in the template, to generate a class shell.</p>\n\n<pre id=\"ccdbf3\"><code class=\"javascript hljs\">const { _Cl } = require('./depack')\n\n/** @constructor {_ns.MyClass} */\nclass MyClass extends _Cl {}</code></pre>\n\n<p>The body of the class will then be generated, however there's no annotations for properties, only member methods. For example, <span class=\"tm2\">@goa/router</span> <a href=\"https://github.com/idiocc/goa-router/blob/master/compile/index.js\">uses</a> this method. <a\n  href=\"https://github.com/idiocc/koa/blob/b6a2ebed556006675a35c1dcf7ee28aacdc3271c/compile/index.js#L7\">\n  Another way</a> to template classes, is to include a typedef of a class in a file, and then use <span class=\"tm\">typeof</span> operator when proxying the type:</p>\n\n<pre id=\"ccdbf4\"><code class=\"javascript hljs\">const { _Goa, _Context } = require('./koa')\n\n/**\n * An application constructor.\n * @type {new (options?: ApplicationOptions) =&gt; Application)}\n */\nconst $Goa = _Goa\n\n/**\n * The default context constructor.\n * @type {new () =&gt; Context}\n */\nconst $Context = _Context\n\nmodule.exports = $Goa\nmodule.exports.Context = $Context</code></pre>\n\n<p>This also works pretty well, however you won't be able to access JSDoc for static methods.</p>\n\n<hr />\n\n<p>In short, we need to use templates to enrich our compiled code with JSDoc annotations, by providing simple shells that are documented with JSDoc comments. All typedefs are also included in the main JS file to be accessed by methods. They are also imported from the source code, either directly or via such files as <strong>types/index.js</strong> that hold methods' typedefs for development purposes, as the main file is the source of truth for types.</p>\n\n</div>\n\n<div data-section id=\"running-compiler\">\n<h3>Running Compiler</h3>\n\n<p>The next step is to execute the compiler. The package that we installed contained a <strong>jar</strong> file, which needs to be passed to Java along with arguments. The arguments must also contain the list of all JS files in the program. That's why <em>Depack</em> also contains a regex-based static analysis tool that scans all files for <span class=\"tm\">import</span> statements, and builds a full list of all files. The algorithm can also detect <span class=\"tm\">require</span> calls, however if at some point you want to use dynamic linking (so that a dependency is required at runtime, rather than compiled into your program), you can use the following construct:</p>\n\n<pre id=\"ccdbf5\"><code class=\"javascript hljs\">const pckg = require(/* depack */ 'dynamic-linking')</code></pre>\n\n<p>In this case, the regex won't pick up the require call. In addition, no require calls from the entry file that we're compiling end up in the arguments. Initially, this was a bug, but I decided to keep it as is, so that in binaries, we can simply do something like that:</p>\n\n<pre id=\"ccdbf6\"><code class=\"javascript hljs\">if (_version) {\n  console.log('v%s', require('../../package.json')['version'])\n}</code></pre>\n\n<p>Importing JSON files with <span class=\"tm\">import</span> also doesn't work in Closure (at least at the time of writing), so you'll need to require them, or read as text and use JSON.parse method to extract JS objects from them.</p>\n\n<p>Since we've prepared and tested our source code already, we can just execute the compiler with <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>lib</span></span></span> command &mdash; <span class=\"tm2\">depack src/depack.js -o compile/trapcss.js -a -c -p --source_map_include_content</span>:</p>\n\n<ul>\n  <li><strong>src/depack.js</strong>, the entry point to compile.</li>\n  <li><strong>-o compile/trapcss.js</strong>, the output location.</li>\n  <li><strong>-a</strong>, enable advanced optimisation.</li>\n  <li><strong>-c</strong>, indicates to <em>Depack</em> that we're <strong>c</strong>ompiling a Node.JS package which enables Node externs.</li>\n  <li><strong>--source&lowbar;map&lowbar;include&lowbar;content</strong>, to include content in source maps. The content is pretty useful, however VSCode won't be able to print the values of variables when you hover over then during <a href=\"https://github.com/Microsoft/vscode/issues/12066\">debugging</a> in which case you might want to pass <span class=\"tm\">&quot;sourceMaps&quot;: false</span> in your launch config when debugging compiled libs.</li>\n</ul>\n\n<p>Other options could include <span class=\"tm\">-p</span>, for pretty output, or <span class=\"tm\">-O ES5</span>, to compile into really old code that could probably be able to run on Node 4 (given the API is supported). The default language output is ES2018. Source maps could be disabled with <span class=\"tm\">-S</span>. Any other <a href=\"https://github.com/google/closure-compiler/wiki/Flags-and-Options\">options</a> to the compiler can also be just passed after the main command. And that's it, there's no config or anything.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"compilation process\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='889' height='652'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"compilation process\" src=\"/nodetools/pages/trapcss2/1-compile/img/compile.gif\">\n  </noscript>\n</p>\n\n<p>Because of type checking, we also received a number of warnings. In part I, we kept the <span class=\"tm\">keepText</span> argument, even though it wasn't used in the source code. The compiler was able to pick up the fact that the config type does not include such property, and that the <span class=\"tm2\">parseHTML</span> method doesn't accept the second argument either. It's really great to use compiler to polish our code so that there are no inaccuracies like that left and our source is 100% professional. It is not possible with <em>Babel</em>, perhaps only with <em>TypeScript</em>.</p>\n\n<p>When we come to remove the <span class=\"tm\">keepText</span> to fix the warning, let's also add the original MIT copyright on the package. The copyright owner didn't include any comment that would have to be preserved, therefore we're under no obligation to include it in our code (only in documentation), but let's do it anyway as good practice. I use the following template for MIT:</p>\n\n<pre id=\"ccdbf7\"><code class=\"javascript hljs\">/*!\n * dropcss by Leon Sorokin\n * https://github.com/leeoniya/dropcss\n * Copyright(c) 2020\n * MIT Licensed\n */</code></pre>\n\n<p>The compiled code is saved into <strong>compile/trapcss.js</strong> file. Let's just have a quick look.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"compiled code\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='972' height='619'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"compiled code\" src=\"/nodetools/pages/trapcss2/1-compile/img/compiled.gif\">\n  </noscript>\n</p>\n\n<p>There's the <span class=\"tm\">use strict</span> directive, both licenses and the assignment to the <span class=\"tm2\">module.exports</span> property. On top, there's also a shebang which is not relevant to compiled libraries, but is needed when we'll be compiling binaries, however <em>Depack</em> just keeps it anyway since it doesn't have any negative effect. If you need to disable <span class=\"tm\">use strict</span>, you can pass the <span class=\"tm\">-s</span> flag to <em>Depack</em>.</p>\n\n\n\n<p>The template has already been prepared so now we actually have our package ready to be published, but we'd like to test the compiled module prior to publishing. Since we should be careful with advanced optimisation that can rename property names, we can now run all our tests but override the import of the source code to import of the compiled code. This is achieved with <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>test-compile</span></span></span> command &mdash; <span class=\"ItWillRunYarn\"><span class=\"tm2\">yarn test -e test-compile</span></span><span class=\"ItWillRunNpm\"><span class=\"tm2\">npm test -- -- -e test-compile</span></span>. It simply calls the test script, but passes the <span class=\"tm\">test-compile</span> variable as testing environment. The environments are configured in the <span class=\"tm\">.alamoderc</span> file:</p>\n\n<pre id=\"cb9de\"><code class=\"json hljs\">{\n  \"env\": {\n    \"test-compile\": {\n      \"import\": {\n        \"replacement\": {\n          \"from\": \"^((../)+)src$\",\n          \"to\": \"$1compile\"\n        }\n      }\n    }\n  }\n}</code></pre>\n\n<p>Now every time we require <span class=\"tm\">../../src</span> from test, the transpiler will update it to <span class=\"tm\">../../compile</span> on the fly (the <span class=\"tm2\">$</span> is needed in cases when we import methods from other files in the lib for unit testing, which would break testing as paths like <strong>compile/html.js</strong> don't exist). We can also set it to just <span class=\"tm\">../..</span> since it will resolve to our <strong>package.json</strong> and read the <span class=\"tm2\">main</span> field from there. To ensure that the remapping actually happens, we can add a simple <span class=\"tm\">throw new Error(1)</span> in the <strong>compile/index.js</strong> file and try to run this command.</p>\n\n<pre id=\"c414d1\"><code class=\"bash hljs\">Testing compile bin\nError: 1\nCould not require test/spec\n    at Object.&lt;anonymous&gt; (/Users/zavr/adc/trapcss/compile/index.js:2:7)\n    at Module.p._compile (/Users/zavr/adc/trapcss/node_modules/alamode/compile/depack.js:49:18)\n    at Object.h.(anonymous function).y._extensions.(anonymous function) [as .js] (/Users/zavr/adc/trapcss/node_modules/alamode/compile/depack.js:51:7)\nerror Command failed with exit code 1.</code></pre>\n\n<p>There was an error, so the imports renaming was correct. Let's remove the error and run test again.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"compiled code tests passing\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='604' height='466'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"compiled code tests passing\" src=\"/nodetools/pages/trapcss2/1-compile/img/tests.gif\">\n  </noscript>\n</p>\n\n<p>All tests pass which is good news! We can also create a test file called <span class=\"tm\">t.js</span> in the project dir, and import the library to test for the presence of autocompletions:</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"test for autocompletions\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='600' height='359'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"test for autocompletions\" src=\"/nodetools/pages/trapcss2/1-compile/img/auto.gif\">\n  </noscript>\n</p>\n\n<p>After manual testing, we find that everything is correct. In <em>NodeTools 2</em>, we'll include a tool to write autocompletion tests since it's not feasible to keep rerunning such tests by hand. But for now, you can use this strategy.</p>\n\n<!-- Lastly, if the copyright owner included the copyright note in his source code, it would had to be preserved also according to MIT. However, he didn't and I didn't bother adding it in the source code. However, we'll want to document it  -->\n\n</div>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/2.svg\"></noscript></a>\n</p>\n</div>\n\n<div data-section id=\"binary-executable\">\n<h2>Binary Executable</h2>\n\n<p>Many packages come with a binary &mdash; a Node script that can be run from the CLI. There are many usages of such scripts, including on CI, or to perform any routine operation from the command line. Binaries need to be defined in <strong>package.json</strong>:</p>\n\n<pre id=\"cb9de1\"><code class=\"json hljs\">\"bin\": {\n  \"trapcss\": \"compile/bin/trapcss.js\",\n  \"trapcss-dev\": \"src/bin/index.js\"\n}</code></pre>\n\n<p>The main bin is pointing to the compiled version, whereas we also add the <span class=\"tm\">dev</span> version, for when we link the package using <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span>link</span></span></span>. This will make its source code executable system-wide without having to recompile it every time for changes. The <strong>index.js</strong> file is the entry point to the development version:</p>\n\n<pre id=\"ccdbf8\"><code class=\"javascript hljs\">#!/usr/bin/env node\nrequire('alamode')()\nrequire('./trapcss')</code></pre>\n\n<p>It simply instantiates the <em>ÀLaMode</em> hook that will transpile modules on the file. It is not used when the binary is built/compiled. We also have a <span class=\"tm\">dev</span> script <span class=\"tm2\">&quot;dev&quot;: &quot;node src/bin&quot;</span> so that we can run <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>dev</span></span></span> from the project folder when testing.</p>\n\n\n\n<div data-section id=\"cli-arguments\">\n<h3>CLI Arguments</h3>\n\n<p>The key requirement for such scripts is to read arguments from the <span class=\"tm\">process.argv</span> array, to parse input flags and options to the program. There are packages that allow to do that, but in <em>NodeTools</em>, we take a different approach. We'll keep our arguments definitions in the <strong>types/arguments.xml</strong> file:</p>\n\n<pre id=\"c16f72\"><code class=\"xml hljs\">&lt;arguments&gt;\n  &lt;arg command multiple name=\"input\"&gt;\n    The HTML files to read.\n  &lt;/arg&gt;\n  &lt;arg name=\"css\" short=\"c\"&gt;\n    The CSS file to drop selectors from.\n  &lt;/arg&gt;\n  &lt;arg name=\"output\" short=\"o\"&gt;\n    The destination where to save output.\n    If not passed, prints to stdout.\n  &lt;/arg&gt;\n  &lt;arg boolean name=\"help\" short=\"h\"&gt;\n    Print the help information and exit.\n  &lt;/arg&gt;\n  &lt;arg boolean name=\"version\" short=\"v\"&gt;\n    Show the version's number and exit.\n  &lt;/arg&gt;\n&lt;/arguments&gt;</code></pre>\n\n<p>Using XML schema, we can maintain the argument specification, and then create a special file called <strong>get-args.js</strong>, using the <span class=\"tm\">argufy</span> package. The script is defined as the <em>args</em> job in <strong>package.json</strong> &mdash; <span class=\"tm2\">argufy -o src/bin/get-args.js</span>. The default location of arguments is <strong>types/arguments.xml</strong>, so we don't need to specify any input. The output, on the other hand, is to be written to <strong>src/bin/get-args.js</strong>. From the specification that we drew, this is the output that is produced:</p>\n\n<pre id=\"ccdbf21\"><code class=\"javascript hljs\">import argufy from 'argufy'\n\nexport const argsConfig = {\n  'input': {\n    description: 'The HTML files to read.',\n    command: true,\n    multiple: true,\n  },\n  'css': {\n    description: 'The CSS file to drop selectors from.',\n    short: 'c',\n  },\n  'output': {\n    description: 'The destination where to save output.\\nIf not passed, prints to stdout.',\n    short: 'o',\n  },\n  'help': {\n    description: 'Print the help information and exit.',\n    boolean: true,\n    short: 'h',\n  },\n  'version': {\n    description: 'Show the version\\'s number and exit.',\n    boolean: true,\n    short: 'v',\n  },\n}\n\nconst args = argufy(argsConfig)\n\n/**\n * The HTML files to read.\n */\nexport const _input = /** @type {!Array&lt;string&gt;} */ (args['input'])\n\n/**\n * The CSS file to drop selectors from.\n */\nexport const _css = /** @type {string} */ (args['css'])\n\n/**\n * The destination where to save output.\n    If not passed, prints to stdout.\n */\nexport const _output = /** @type {string} */ (args['output'])\n\n/**\n * Print the help information and exit.\n */\nexport const _help = /** @type {boolean} */ (args['help'])\n\n/**\n * Show the version's number and exit.\n */\nexport const _version = /** @type {boolean} */ (args['version'])\n\n/**\n * The additional arguments passed to the program.\n */\nexport const _argv = /** @type {!Array&lt;string&gt;} */ (args._argv)</code></pre>\n\n<p>The program generated the config, that will be passed to <span class=\"tm\">argufy</span> at runtime, to create the <span class=\"tm2\">args</span> object. Then, each of arguments is actually casted into its correct type, annotated with description and declared as a named export. This will allow to statically import those arguments from the binary. Such approach enables type checking using <em>Closure Compiler</em>, as arguments are constructed statically. <span class=\"tm\">argufy</span> doesn't have any dependencies, but if we compile the binary, it will also be merged into it meaning there's absolutely no overhead into using it. Because <em>input</em> is specified as <strong>multiple command</strong>, it will be an array of strings, so that we can pass multiple paths to HTML files.</p>\n\n<ul>\n  <li>Read more about <a href=\"https://github.com/artdecocode/argufy\">argufy</a>;</li>\n  <li>Multiple arguments.xml files can be kept, for different <a\n  href=\"https://github.com/artdecocode/logarithm/tree/14ce888bec311c4febdf591e98eaedb00efdee47/types/args\">\n  semantic functionality</a>;</li>\n  <li>Short aliases can be reused between commands, check out <a\n  href=\"https://github.com/artdecocode/logarithm/blob/14ce888bec311c4febdf591e98eaedb00efdee47/src/bin/logarithm.js#L110\">\n  logarithm</a>;</li>\n  <li>At the moment, an argument cannot be both flag (boolean) and standard argument, e.g., <span class=\"tm\">trapcss -c</span> AND <span class=\"tm\">trapcss -c path.css</span> are not possible at the same time. I'll be adding this later on.</li>\n</ul>\n\n</div>\n\n<div data-section id=\"implementation\">\n<h3>Implementation</h3>\n\n<p>The template has already come with some binary source code, for example for printing version number and usage information. The usage string is constructed with the <span class=\"tm\">usually</span> package, that accepts a description, example, line and usage itself. The usage is made using the <span class=\"tm2\">reduceUsage</span> method from <span class=\"tm\">argufy</span>, based on the arguments config that was also exported from the <strong>get-args.js</strong> file. It will create a 2-column table with full and short arguments' names and their descriptions.</p>\n\n<pre id=\"ccdbf22\"><code class=\"javascript hljs\">import usually from 'usually'\nimport { reduceUsage } from 'argufy'\nimport { readFileSync, writeFileSync } from 'fs'\nimport { c } from 'erte'\nimport { _input, _output, argsConfig, _css, _version, _help } from './get-args'\nimport trapcss from '../'\n\n/*!\n * TrapCSS: Remove unused CSS selectors based on HTML files.\n *\n * Copyright (C) 2020 Art Deco Code Limited\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n */\n\nif (_help) {\n  const usage = usually({\n    description: 'Remove unused CSS',\n    example: 'trapcss index.html example.html -c style.css -o style-dropped.css',\n    line: 'trapcss input.html[,n.html,...] -c style.css [-o output] [-hv]',\n    usage: reduceUsage(argsConfig),\n  })\n  console.log(usage)\n  process.exit(0)\n} else if (_version) {\n  console.log(require('../../package.json').version)\n  process.exit(0)\n}\n\nif (!_css) {\n  console.error('Please pass CSS path')\n  process.exit(1)\n}\nconst css = /** @type {string} */ (readFileSync(_css, 'utf8'))\n\n// whitelist\nlet whitelist = new Set()\n\n_input.forEach((input) =&gt; {\n  const html = /** @type {string} */ (readFileSync(input, 'utf8'))\n  const { sels } = trapcss({\n    css,\n    html,\n  })\n  sels.forEach(sel =&gt; whitelist.add(sel))\n})\n\nconst cleaned = trapcss({\n  html: '',\n  css,\n  shouldDrop: sel =&gt; !whitelist.has(sel),\n})\n\nif (_output) {\n  writeFileSync(_output, cleaned.css)\n  console.error('Output written to %s', c(_output, 'yellow'))\n} else {\n  console.log(cleaned.css)\n}</code></pre>\n\n<p>We can see what the usage looks like by calling the <strong>dev</strong> script: <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>dev</span> <span class=\"npm-cmd\">--</span> <span>-h</span></span></span>:</p>\n\n<pre id=\"c414d2\"><code class=\"bash hljs\">Remove unused CSS\n\n  trapcss input.html[,n.html,...] -c style.css [-o output] [-hv]\n\n        input           The HTML files to read.\n        --css, -c       The CSS file to drop selectors from.\n        --output, -o    The destination where to save output.\n                        If not passed, prints to stdout.\n        --help, -h      Print the help information and exit.\n        --version, -v   Show the version's number and exit.\n\n  Example:\n\n    trapcss index.html example.html -c style.css -o style-dropped.css</code></pre>\n\n<p>This presentation might be different from how you want it to look like, so feel free to implement your own usage function from the args config, or submit a <a href=\"https://github.com/artdecocode/usually\">PR</a> to the <span class=\"tm\">usually</span> package with new options for styling.</p>\n\n<p>Moreover, we required <strong>package.json</strong> at runtime, which means that it won't be built into the compiled code, and will remain as <span class=\"tm\">require</span> call. Requires from the entry file don't make it to the dependency list during static analysis, but if we wanted to make dynamic import anywhere else, it'd have to be broken up:</p>\n\n<pre id=\"ccdbf9\"><code class=\"javascript hljs\">const pckg = require(/* dpck */ 'dynamic-import')</code></pre>\n\n<p><em>version</em> is a recognised option by the compiler, so we don't have to use quoted props, for other fields, we'd have to refer to them like <span class=\"tm\">require('../../package')['main']</span> to avoid renaming.</p>\n\n<p>Next, we check if the CSS was supplied via the arguments. If it wasn't we print an error message and exit with status code 1, which means that the program wasn't executed successfully and is a unix convention. Otherwise, we'll read the CSS file, using standard <strong>readFileSync</strong>. Typically, in Node, we're trained to use promises for non-blocking IO, however because we're not running a server, and simply executing a script, it's absolutely appropriate to use sync operations in this case (unless we're reading/writing many files in parallel). We used casting, because if the second argument (encoding) is not passed to <span class=\"tm2\">readFileSync</span>, it will return a buffer, but the compiler does not support overloading, so we have to explicitly cast the return type. This is done by wrapping the value in brackets:</p>\n\n<pre id=\"ccdbf10\"><code class=\"javascript hljs\">/** @type {string} */ (readFileSync(input, 'utf8'))</code></pre>\n\n<p><em>DropCSS</em> provides a strategy for reading multiple input files. We create a <span class=\"tm\">whitelist</span> set, and then for each HTML file, execute the <span class=\"tm2\">trapcss</span> method against it and CSS, and add selectors to the set. In the end, we simply pass an empty string as HTML, but use <span class=\"tm\">shouldDrop: sel =&gt; !whitelist.has(sel)</span> property of the config that will utilise the accumulated whitelist.</p>\n\n<p>Finally, if the <span class=\"tm\">-o</span> argument was passed, we can save the result to a file. If not, we print the output to stdout to the user. We used the <span class=\"tm2\">c</span> method from <span class=\"tm\">erte</span> to print the output location in yellow. It also contains the <span class=\"tm2\">b</span> method to color the background of strings, and the two can be combined. The template came with <span class=\"tm\">indicatrix</span> package also that would print a loading indicator (triple ellipse) however we didn't have any async operations so it could be removed.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"running trapcss from CLI\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='654' height='508'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"running trapcss from CLI\" src=\"/nodetools/pages/trapcss2/2-bin/img/t.gif\">\n  </noscript>\n</p>\n\n</div>\n\n<div data-section id=\"fork-testing\">\n<h3>Fork Testing</h3>\n\n<p>We already used some mask testing in <a href=\"/nodetools/trap\"></a>, but one of the best applications of masks is to test forks. A fork is a separate Node process spawned from a script itself. They are completely independent processes with separate PIDs, but the fork will by default exit with its parent. Since our binary is a Node program, to test it properly, we need to spawn it via the <span class=\"tm\">child_process</span> module. <em>Zoroaster</em> provides an abstraction over fork testing, if you pass <span class=\"tm2\">fork</span> property to the mask constructor.</p>\n\n<pre id=\"ccdbf23\"><code class=\"javascript hljs\">import TempContext from 'temp-context'\nimport Context from '../context'\nimport makeTestSuite from '@zoroaster/mask'\n\nexport default makeTestSuite('test/result/bin/default', {\n  context: TempContext,\n  fork: {\n    /**\n     * @param {string[]} args\n     * @param {TempContext} t\n     */\n    async getArgs(_, { write }) {\n      const html = await write('index.html', this.input)\n      const [, css] = /&lt;style&gt;([\\s\\S]+?)&lt;\\/style&gt;/.exec(this.css)\n      const style = await write('style.css', css)\n      return [html, '-c', style]\n    },\n    module: Context.BIN,\n    preprocess: {\n      stdout: Context.wrap,\n    },\n  },\n})</code></pre>\n\n<p>By default, the input from mask result is split by whitespace to provide arguments to fork, but we can provide the <span class=\"tm\">getArgs</span> method to expand, or override the arguments list. We'll use a testing context called <em>TempContext</em> to write the input of the mask into a temp file (<span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-cmd\">i</span><span class=\"yarn-cmd\">add</span> <span>temp-context</span></span></span>). For each test, a blank <span class=\"tm2\">test/temp</span> dir will be created, and removed at the end. The <strong>write</strong> method returns the path to the new file, so that we can pass it to the program. We then extract the CSS from within the <span class=\"tm2\">style</span> tag in the mask result (need to wrap it in the style tag for syntax highlighting), and also write it to the temp dir. The new arguments, therefore are: [path-to.html -c path-to.css].</p>\n\n<p>As a preprocessor for output, we also want to wrap the <span class=\"tm\">stdout</span> in style tag also, for syntax highlighting. The tag itself has no meaning to tests themselves, it only allows US as developers to work comfortably with mask results. <em>NodeTools</em> is all about usability, and we can even do some cools stuff as folding individual specs in the result file, since they are under <span class=\"tm\">##</span> heading of a markdown file.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"folding mask results from IDE\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='600' height='467'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"folding mask results from IDE\" src=\"/nodetools/pages/trapcss2/2-bin/img/wrap.gif\">\n  </noscript>\n</p>\n\n<p>Additionally, we had to get the path to the fork from the context's static <span class=\"tm\">BIN</span> property, that accounts for the testing environment:</p>\n\n<pre id=\"ccdbf11\"><code class=\"javascript hljs\">// test/context/index.js\nlet BIN = 'src/BIN'\nif (process.env.ALAMODE_ENV == 'test-compile') {\n  console.log('Testing compile bin...')\n  BIN = 'compile/bin/trapcss'\n}</code></pre>\n\n<p>This will be useful later after we've compiled the binary with <em>Closure</em>.</p>\n\n<pre id=\"c1953\"><code class=\"markdown hljs\">## keeps span\n&lt;html&gt;\n  &lt;body&gt;\n    &lt;span&gt;test&lt;/span&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n/* css */\n&lt;style&gt;\n  span {\n    color: green;\n  }\n&lt;/style&gt;\n/**/\n\n/* stdout */\n&lt;style&gt;\n  span{color: green;}\n&lt;/style&gt;\n/**/\n\n## removes div\n&lt;html&gt;\n  &lt;body&gt;\n    &lt;span&gt;test&lt;/span&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n\n/* css */\n&lt;style&gt;\n  span {\n    color: yellow;\n  }\n  div {\n    color: green;\n  }\n&lt;/style&gt;\n/**/\n\n/* stdout */\n&lt;style&gt;\n  span{color: yellow;}\n&lt;/style&gt;\n/**/</code></pre>\n\n<p>We only do a couple of tests to make sure that the binary doesn't throw any errors and processes arguments correctly. Most of the unit tests were done on the API, therefore it'd be redundant to test the same functionality twice. However, we could potentially construct a mask that would use input from mask results to the API to adapt them to pass to the CLI, but I won't do it here. Since mask results are just text files, they can be reused according to your imagination.</p>\n\n<pre id=\"ccdbf24\"><code class=\"javascript hljs\">import TempContext from 'temp-context'\nimport Context from '../context'\nimport makeTestSuite from '@zoroaster/mask'\n\nexport const output = makeTestSuite('test/result/bin/output', {\n  context: TempContext,\n  fork: {\n    /**\n     * @param {string[]} args\n     * @param {TempContext} t\n     */\n    async getArgs(args, { resolve }) {\n      return [...args, '-o', resolve('style-trap.css')]\n    },\n    module: Context.BIN,\n  },\n  /**\n   * @param {TempContext} t\n   */\n  async getResults({ read }) {\n    const s = await read('style-trap.css')\n    return Context.wrap(s)\n  },\n})\n</code></pre>\n\n<p>The second test is almost the same as the first one, except that we add the output argument to the list of arguments from the input, instead of completely overriding the arguments array. The path to the output is generated with the <span class=\"tm\">resolve</span> method from the temp context, which we passed in the <strong>context</strong> property. The question is then how to test the output of the program? To do that, we need to implement the <span class=\"tm2\">getResults</span> method that will also receive the context, so that we can call the <span class=\"tm2\">read</span> method from testing API. As previously, we want to wrap the output for syntax highlighting.</p>\n\n<pre id=\"c19531\"><code class=\"markdown hljs\">## writes the output file\ntest/fixture/surveillance.html -c test/fixture/bootstrap.min.css\n\n/* stderr */\nOutput written to test/temp/style-trap.css\n/**/\n\n/* expected */\n&lt;style&gt;\n  *,::after,::before{box-sizing:border-box}html{...}\n&lt;/style&gt;\n/**/\n</code></pre>\n\n<p>The mask result provides 2 properties: <span class=\"tm\">stderr</span> and <span class=\"tm\">expected</span>. We're not testing for <span class=\"tm\">stdout</span> since there's no output on this stream, and we implemented the <span class=\"tm2\">getResults</span> method to read the expected result from a file in the temp folder.</p>\n\n<p>As previously, we could leave the mask result values blank, and run tests in interactive mode <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span>test</span> <span class=\"npm-cmd\">--</span> <span>-i</span></span></span>, for the testing framework to populate them for us.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"updating mask forks in interactive mode\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='600' height='568'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"updating mask forks in interactive mode\" src=\"/nodetools/pages/trapcss2/2-bin/img/i.gif\">\n  </noscript>\n</p>\n\n<p>For the final test, we'll make the simplest mask possible, by only passing the path to the binary:</p>\n\n<pre id=\"ccdbf12\"><code class=\"javascript hljs\">export const stress = makeTestSuite('test/result/bin/stress', {\n  fork: Context.BIN,\n})</code></pre>\n\n<p>When there's no additional configuration, only <strong>stdout</strong>, <strong>stderr</strong> and <strong>code</strong> properties are asserted on.</p>\n\n<pre id=\"c19532\"><code class=\"markdown hljs\">## cleans the css\ntest/fixture/surveillance.html -c test/fixture/bootstrap.min.css\n\n/* stdout */\n*,::after,::before{box-sizing:border-box}html{...}\n/**/\n\n## gives error when CSS is not passed\ntest/fixture/surveillance.html\n\n/* stderr */\nPlease pass CSS path\n/**/\n\n/* code */\n1\n/**/</code></pre>\n\n<p>In the first test, like before, we passed paths to HTML and CSS, but we didn't need to use the temp context since the output is printed to stdout. In the second test we added the <span class=\"tm\">code</span> property to test that the fork will exit with code <em>1</em> when a path to the CSS file is not passed, and that <strong>stderr</strong> contains the error message.</p>\n\n<p>As you can see, testing forks is very simple with <em>Zoroaster</em> that provides means to setup tests to run parallel processes, and assert on outputs. The tests themselves are not run in parallel, but there's no point to it anyway, as running them in parallel will slow down the CPU and consume more memory, so that there's no difference between running 5 tests in parallel that take 1 second each, or 5 tests in series that take 0.2 seconds each, so don't listen to anyone who advertises parallel testing as an advantage, unless it's IO time that is being parallelised, and not CPU time.</p>\n\n<p>Even if a program required interaction from <strong>stdin</strong>, such as entering answers, we could still test it by either providing the <span class=\"tm\">[stderr]Inputs</span> property of the mask, or via the <span class=\"tm\">inputs</span> <a\n  href=\"https://raw.githubusercontent.com/artdecocode/expensive/885e62298c05b75eedb2dbb298e8544823d1a0c2/test/result/fork/register.md\">\n  property</a> in the mask result.</p>\n\n<p>Fork testing is more expensive as it requires time to spawn forks, therefore it's preferable to do as many unit tests as possible, and design binary in such a way as it would be possible to require commands called from binary in tests, instead of spawning forks. That's why the template comes with the <span class=\"tm\">init</span> command, but it could be removed now since our binary is fairly straight-forward.</p>\n\n</div>\n\n<div data-section id=\"bin-compile\">\n<h3>Bin Compile</h3>\n\n<p>We now want to compile the binary. <em>NodeTools</em> is perfect for this task, as the program produced will have no dependencies at all. The <strong>package.json</strong> file already comes with a command to run <em>Depack</em> on the binary <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>compile</span></span></span> (the <strong>lib</strong> script is to compile library instead, which we've already done). The script evaluates to <span class=\"tm2\">depack src/bin/trapcss -o compile/bin/trapcss.js -a -c -S --externs types/externs.js</span>:</p>\n\n<ul>\n  <li><strong>src/bin/trapcss</strong>, the file to compile, from which all dependencies will be statically analyzed.</li>\n  <li><strong>-o compile/bin/trapcss.js</strong>, the path to the output file.</li>\n  <li><strong>-a</strong>, advanced compilation.</li>\n  <li><strong>-c</strong>, compilation flag (needed to enable Node externs).</li>\n  <li><strong>-S</strong>, no source maps, as we're not expecting that our bin will be debugged, unlike library, which might be jumped in.</li>\n  <li><strong>--externs types/externs.js</strong>, in the library, we imported externs from <strong>src/depack.js</strong> file, however we can also pass it via the argument to CLI. Previously, <strong>src/depack.js</strong> that imported externs wasn't ever run and only passed to <em>Closure</em> as entry, but if we used an import in bin, the externs file would be evaluated which is unnecessary.</li>\n</ul>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"compilation process\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='748' height='483'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"compilation process\" src=\"/nodetools/pages/trapcss2/2-bin/img/bc.gif\">\n  </noscript>\n</p>\n\n<p><em>Depack</em> will discover all built-in Node modules, add apply externs for those. Global and Buffer externs are always added (even if <em>Buffer</em> isn't used). You might see a message <em>\"Skipping package usually that imports itself in node&lowbar;modules/usually/src/index.js\"</em>, because <span class=\"tm\">usually</span> has an example usage where in its JSDoc it gives a snippet with an import:</p>\n\n<pre id=\"ccdbf13\"><code class=\"javascript hljs\">/**\n * Generate a usage string.\n * @param {!_usually.Config} config The configuration object.\n * @example\n```\nimport usually from 'usually'\n\nconst res = usually({\n  description: 'A test command-line application',\n})\n```\n */\nexport default function usually(config = { usage: {} }) {</code></pre>\n\n<p>Static analysis is based on regexes, so if you ever encounter any problems with it, e.g., false positive imports detection where your imports are just placed in a string, for example, you should break up the import so it becomes undetectable:</p>\n\n<pre id=\"ccdbf14\"><code class=\"javascript hljs\">// false positive\nconst myString = `// auto-generated code\nimport package from 'package'\n`\n// becomes\nconst myString = `// auto-generated code\ni` + `mport package from 'package'\n`</code></pre>\n\n<p>I know it's not perfect, but I'd rather keep simple regexes for the analysis of ECMA modules, instead of increasing complexity by building of ASTs <em>etc</em>. The whole purpose of <em>NodeTools</em> is to be really simple yet effective.</p>\n\n<p>The result of compilation is saved into the <span class=\"tm\">compile/bin/trapcss.js</span>, and the file is assigned executable rights so that it can be called from shell, as it has got the shebang with the <span class=\"tm2\">node</span> env.</p>\n\n<pre id=\"ccdbf15\"><code class=\"javascript hljs\">#!/usr/bin/env node\n'use strict';\nconst fs = require('fs');             function q(){var a={description:\"Remove unused CSS\",example:\"trapcss index.html example.html -c style.css -o style-dropped.css\",line:\"trapcss input.html[,n.html,...] -c style.css [-o output] [-hv]\",usage:v()};const {usage:b={},description:c,line:d,example:f}=a;a=Object.keys(b);const g=Object.values(b),[e]=a.reduce(([h=0,m=0],p)=&gt;{const t=b[p].split(\"\\n\").reduce((r,n)=&gt;n.length&gt;r?n.length:r,0);t&gt;m&amp;&amp;(m=t);p.length&gt;h&amp;&amp;(h=p.length);return[h,m]},[]),k=(h,m)=&gt;{m=\" \".repeat(m-h.length);return`${h}${m}`};\na=a.reduce((h,m,p)=&gt;{p=g[p].split(\"\\n\");m=k(m,e);const [t,...r]=p;m=`${m}\\t${t}`;const n=k(\"\",e);p=r.map(u=&gt;`${n}\\t${u}`);return[...h,m,...p]},[]).map(h=&gt;`\\t${h}`);const l=[c,`  ${d||\"\"}`].filter(h=&gt;h?h.trim():h).join(\"\\n\\n\");a=`${l?`${l}\\n`:\"\"}\n${a.join(\"\\n\")}\n`;return f?`${a}\n  Example:\n\n    ${f}\n`:a};const w=(a,b,c,d=!1,f=!1)=&gt;{const g=c?new RegExp(`^-(${c}|-${b})$`):new RegExp(`^--${b}$`);b=a.findIndex(e=&gt;g.test(e));if(-1==b)return{argv:a};if(d)return{value:!0,index:b,length:1};d=a[b+1];if(!d||\"string\"==typeof d&amp;&amp;d.startsWith(\"--\"))return{argv:a};f&amp;&amp;(d=parseInt(d,10));return{value:d,index:b,length:2}},x=a=&gt;{const b=[];for(let c=0;c&lt;a.length;c++){const d=a[c];if(d.startsWith(\"-\"))break;b.push(d)}return b},v=()=&gt;{var a=z;return Object.keys(a).reduce((b,c)=&gt;{const d=a[c];if(\"string\"==typeof d)return b[`-${d}`]=\n\"\",b;c=d.command?c:`--${c}`;d.short&amp;&amp;(c=`${c}, -${d.short}`);let f=d.description;d.default&amp;&amp;(f=`${f}\\nDefault: ${d.default}.`);b[c]=f;return b},{})};const A=fs.readFileSync,B=fs.writeFileSync;/*\n diff package https://github.com/kpdecker/jsdiff\n BSD License\n Copyright (c) 2009-2015, Kevin Decker &lt;kpdecker@gmail.com&gt;\n*/\nconst aa={black:30,/* ... */}</code></pre>\n\n<p>You might see the copyright for the <span class=\"tm\">diff</span> package, as there's a script in <em>Erte</em> (string coloring) to diff strings. Although it was dropped by <em>Closure</em>'s tree shaking, the comment is left over anyway as <em>Closure</em> preserves all important comments. <em>Depack</em> will implement its own tree shaking, as much as possible, in future versions, to limit the number of JS files passed to the compiler.</p>\n\n<p>To test the package, I call</p>\n\n<pre id=\"c724c\"><code class=\"shell hljs\">node compile/bin/trapcss.js test/fixture/surveillance.html \\\n     -c test/fixture/bootstrap.min.css</code></pre>\n\n<p>and check if the output is printed to <strong>stdout</strong> which it is.</p>\n\n<p>We also have to test the produced binary. Our <span class=\"tm2\">test-compile</span> script will set the appropriate environment, and since the path to the <span class=\"tm\">BIN</span> for mask-testing comes from the context, it will equal to <strong>compile/bin/trapcss</strong>, so that the compiled module, and not our source code, that will be forked. You'll be able to verify it as <em>Zoroaster</em> will print the confirmation as the first line in the output:</p>\n\n<pre id=\"c724c1\"><code class=\"shell hljs\">Testing compile bin</code></pre>\n\n<p>After tests pass, we know that our compiled bin is fully functional.</p>\n\n</div>\n\n<div data-section id=\"cli-documentation\">\n<h3>CLI Documentation</h3>\n\n<p>I want to let my users know how to use <em>TrapCSS</em> from the <strong>CLI</strong>. Without <em>NodeTools</em>, I'd have to manually execute the binary, and copy-paste the help output into the README file. But we want to automate this process, to</p>\n\n<ol>\n  <li>Save time taken to manually copy-paste data between terminal and documentation;</li>\n  <li>Prevent documentation from becoming out-of-date when changes are made;</li>\n  <li>Detect any errors if there were problems with the binary;</li>\n  <li>Turn documentation into specification as our program will now always confirm to the published contract.</li>\n</ol>\n\n<p>The template already included <strong>documentary/2-CLI/index.md</strong> file, but we want to build upon it a little bit, by giving a more precise example. We'll need to create <strong>example/cli/index.html</strong> and <strong>example/cli/style.css</strong> files with some input data:</p>\n\n<pre id=\"c16f7\"><code class=\"xml hljs\">&lt;!-- example/cli/index.html --&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;TrapCSS ftw&lt;/title&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n      &lt;p&gt;Hello World!&lt;/p&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</code></pre>\n\n<pre id=\"c1d47\"><code class=\"css hljs\">/* example/cli/style.css */\nhtml {\n  background: yellow;\n  /* @alternate */\n  background: green;\n}\n.card {\n  padding: 8px;\n}\np:hover a:first-child {\n  color: red;\n}</code></pre>\n\n<p>The updated CLI section of the documentation is pretty simple and includes a 2-column table that lists the examples, and the output. The table with arguments will also be included automatically by the <span class=\"tm2\">argufy</span> component that comes with <em>Documentary</em>:</p>\n\n<pre id=\"c19533\"><code class=\"markdown hljs\">## CLI\n\nThe package can also be used from the CLI.\n\n&lt;argufy&gt;types/arguments.xml&lt;/argufy&gt;\n\nFor example, having these two files, we can use `trapcss` from the command line:\n\n&lt;table&gt;\n&lt;tr&gt;\n  &lt;th&gt;HTML file&lt;/th&gt;\n  &lt;th&gt;CSS file&lt;/th&gt;\n&lt;/tr&gt;\n&lt;tr&gt;\n  &lt;td&gt;\n\n  %EXAMPLE: example/cli/index.html%\n  &lt;/td&gt;\n  &lt;td&gt;\n\n  %EXAMPLE: example/cli/style.css%\n  &lt;/td&gt;\n&lt;/tr&gt;\n&lt;/table&gt;\n\n```console\ntrapcss:~$ trapcss example/cli/index.html -c example/cli/style.css\n```\n\n%FORK-css src/bin/trapcss example/cli/index.html -c example/cli/style.css%\n\nThe help can be accessed with the `-h` command:\n\n%FORK src/bin/trapcss -h%\n\n%~%</code></pre>\n\n\n<p>We then give a console line of how to run our binary, and include the <span class=\"tm2\">%FORK-css%</span> marker, which means that the language of the output block will be CSS for syntax-highlighting on <em>GitHub</em>.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"CLI documentation section\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='474' height='608'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"CLI documentation section\" src=\"/nodetools/pages/trapcss2/2-bin/img/bin-doc.png\">\n  </noscript>\n</p>\n\n<p>The README section is now compiled in the most automated way possible, leaving us time to work on implementation, testing and new feature design. Remember that we can run <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>doc</span> <span class=\"npm-cmd\">--</span> <span>-p \"doc cli\"</span></span></span> to keep <em>Documentary</em> running in watch mode, and automatically push any changes upstream.</p>\n\n</div>\n\n\n\n<p>Now that we have a 0-dependency binary for <em>TrapCSS</em>, let's add add some more documentation.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='9'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/3.svg\"></noscript></a>\n</p>\n</div>\n\n<div data-section id=\"wiki\">\n<h2>Wiki</h2>\n\n<p>Putting documentation on <em>GitHub</em> wikis is a great way to organise help to our package. README files can be used to provide initial information about package usage, whereas Wikis can be used to described advanced use cases and intricacies of working with our software. Moreover, unlike website, especially if based on custom domains, Wikis will always remain attached to the package on <em>GitHub</em>. Unfortunately, Wikis have not been that popular, since it wasn't easy to maintain them. <em>Documentary</em> fixes this as it supports automatic compilation of docs into <em>Wikis</em>.</p>\n\n<p>When I was creating a new package from the template, I was asked if I wanted to set up a wiki page, to which I said yes, and had to navigate to <em>GitHub</em> to create the first page. This is because <em>GitHub</em> API doesn't provide a method to automate this, however it's not a problem as it only takes a few clicks. Wikis are represented as separate git trees, so for ease of maintenance, <em>MNP</em> initialised a git <strong>submodule</strong> called <strong>wiki.git</strong> in our project, and cloned the tree in there. Now pages from <strong>wiki</strong> will be compiled into <strong>wiki.git</strong> and we'll need to push changes to the submodule separately from the main project.</p>\n\n<p>The template came with <strong>wiki/Developing</strong> page, but it can be removed. I'm going to place original documentation from <em>DropCSS</em> into separate pages. The pages could be either directories, or simple MD files. Additionally, special files include <span class=\"tm\">_Sidebar.md</span> and <span class=\"tm\">_Footer.md</span>, for example our footer uses a component from <strong>.documentary/index.jsx</strong>:</p>\n\n<pre id=\"ccdbf16\"><code class=\"javascript hljs\">&lt;footer /&gt;</code></pre>\n\nWe already described how to use the package in README, so let's add the features page.\n\n<div data-section id=\"features\">\n<h3>Features</h3>\n\n<p>This page contains description of supported features. I've simply copied the table from the source. A cool thing we can do, though, is to create an example file right in the <em>Features</em> directory itself, as it won't be read by <em>Documentary</em> that scans for <span class=\"tm\">md</span>, <span class=\"tm\">markdown</span> and <span class=\"tm\">htm[l]</span> files only. We can then simply pass the relative path to the example:</p>\n\n<pre id=\"c10fc\"><code class=\"md hljs\">- Deep resolution of composite CSS variables, e.g:\n  %EXAMPLE: ./example.css%</code></pre>\n\n<p>Mind the indentation that is used with the example marker &mdash; it's needed so that <em>GitHub</em> recognises it as part of the list item.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"features wiki page\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='515' height='551'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"features wiki page\" src=\"/nodetools/pages/trapcss2/3-wiki/img/features.png\">\n  </noscript>\n</p>\n\n</div>\n\n<div data-section id=\"performance\">\n<h3>Performance</h3>\n\n<p>This page contains some benchmark data for <em>DropCSS</em>. I'll keep it the same.</p>\n\n</div>\n\n<div data-section id=\"javascript-execution\">\n<h3>JavaScript Execution</h3>\n\n<p>This page is about opening a webpage in a headless browser to execute any dynamic JavaScript, which might manipulate DOM, so that the list of selectors is gathered after scripts are executed. I want to use the example, but the original depends on <span class=\"tm\">puppeteer</span> which I think is redundant because if you have Chrome installed on your system, you can already open it. I don't want to download 80MB of a browser just for a simple script to be executed, so we'll simply install <span class=\"tm\">chrome-remote-interface</span> and launch Chrome by hand. There's also <span class=\"tm\">chrome-launcher</span> package however it's got 5 dependencies so until I've made a 0-dep fork, I'm not going to use it.</p>\n\n<pre id=\"c10fc1\"><code class=\"md hljs\">%EXAMPLE: ./execution, ../.. =&gt; trapcss%\n\n%FORK-js ./execution%</code></pre>\n\n<p>The example fork that spawns Chrome is going to be cached, so unless we make changes to the source code and recompile the package, we won't need to wait again for Chrome to start and load pages.</p>\n\n<pre id=\"ccdbf25\"><code class=\"javascript hljs\">import idio from '@idio/idio'\nimport CDP from 'chrome-remote-interface'\nimport { spawn } from 'child_process'\nimport rqt from 'rqt'\nimport trapcss from '../..'\n\n(async () =&gt; {\n  const { app, url } = await idio({\n    static: {\n      use: true,\n      root: 'example/www',\n    },\n  })\n  const chrome = await new Promise((r) =&gt; {\n    const p = spawn('/Applications/Google Chrome.app/Contents/MacOS/Google Chrome',\n      ['--remote-debugging-port=9222', '--headless'])\n    p.stderr.on('data', (d) =&gt; {\n      d = `${d}`\n      if (/listening/.test(d)) setTimeout(() =&gt; r(p), 1000)\n    })\n  })\n  try {\n    const client = await CDP()\n    const { Network, Page, Runtime } = client\n    await Network.enable()\n    await Page.enable()\n    await Page.navigate({ url })\n    await Page.loadEventFired()\n    const { result: { value: html } } = await Runtime.evaluate({\n      expression: 'document.documentElement.outerHTML',\n    })\n    const { result: { value: links } } = await Runtime.evaluate({\n      expression: `[...document.querySelectorAll(\"link[rel=stylesheet]\")]\n        .map((el) =&gt; el.href)`,\n      returnByValue: true,\n    })\n    await client.close()\n\n    await Promise.all(links.map(async href =&gt; {\n      const css = await rqt(href)\n      let start = +new Date()\n\n      const clean = trapcss({\n        css,\n        html,\n      })\n\n      console.log({\n        stylesheet: href,\n        cleanCss: clean.css,\n        elapsed: +new Date() - start,\n      })\n    }))\n  } catch (err) {\n    console.log(err)\n  } finally {\n    await app.destroy()\n    chrome.kill()\n  }\n})()\n</code></pre>\n\n<p>I can also start <em>Documentary</em> in watch mode for Wikis also: <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>wiki</span> <span class=\"npm-cmd\">--</span> <span>-p 'wiki pages'</span></span></span>. Now it will watch for changes in both project and submodule directories, and force-push updates as necessary.</p>\n\n</div>\n\n<div data-section id=\"accumulating-whitelist\">\n<h3>Accumulating Whitelist</h3>\n\n<p>There are some instructions on how to gather HTML selectors from multiple files, if CSS is reused across web pages. I'll copy the instructors and create an example also. When naming Wiki pages like <span class=\"tm\">Accumulating-a-Whitelist</span>, hyphens become whitespace in titles.</p>\n\n<pre id=\"c10fc2\"><code class=\"md hljs\">-= INSTRUCTIONS =-\n\n%EXAMPLE: ./whitelist, ../.. =&gt; trapcss%\n%FORK-css ./whitelist%</code></pre>\n\n<p>In watch mode, new examples will automatically be added to git tree also. Notice how I've imported the package from <span class=\"tm\">../..</span> rather than from source. This is because I want to build documentation against the compiled code, so that I can be sure it's working. It's up to you whether you use source and compile target for documentation since ideally you'll be running <span class=\"tm\">test-compile</span> so that they should produce identical results.</p>\n\n</div>\n\n<div data-section id=\"special--escaped-sequences\">\n<h3>Special / Escaped Sequences</h3>\n\n<p>This page describes the problems with special characters in class names. I'll copy the description and give examples of how to overcome this difficulty. We can't have <span class=\"tm2\">/</span> in the page name, so we'll just call it <em>Special AND Escaped Sequences</em>. We'll want to place an example with HTML into the wiki folder, but to prevent <em>Documentary</em> from reading it, we'll make it hidden by adding a dot: <span class=\"tm\">.index.html</span>.</p>\n\n<p>Our example will also be cropped by using <span class=\"tm2\">/* start/end example */</span> marker:</p>\n\n<pre id=\"ccdbf17\"><code class=\"javascript hljs\">import { join } from 'path'\nimport { readFileSync } from 'fs'\nimport trapcss from '../..'\n\nconst html = readFileSync(join(__dirname, 'index.html'), 'utf8')\nconst css = readFileSync(join(__dirname, 'index.css'), 'utf8')\n\n/* start example */\n// remap\nlet css2 = css\n  .replace(/\\\\:/gm, '__0')\n  .replace(/\\\\\\//gm, '__1')\n  .replace(/\\\\\\?/gm, '__2')\n  .replace(/\\\\\\(/gm, '__3')\n  .replace(/\\\\\\)/gm, '__4')\n// more code\n/* end example */</code></pre>\n\n<p>This is so that we don't have to include admin set up of reading files in the example itself. Also despite me using import statements, and the file being a module, I can still use <span class=\"tm\">__dirname</span>. This is perfect as there's absolutely no reason for Node to make everyone's life really difficult by removing this feature in .mjs files... We're here to make programs not worship standards.</p>\n\n<p>In the end, there's another way to embed a fork:</p>\n\n<pre id=\"c16f71\"><code class=\"xml hljs\">&lt;fork lang=\"css\"&gt;./&lt;/fork&gt;</code></pre>\n\n<p>This is equivalent to <span class=\"tm2\">%FORK-css ./%</span> and is a preferred method as <em>Documentary</em> is switching to components now.</p>\n\n</div>\n\n<div data-section id=\"caveats--acknowledgements\">\n<h3>Caveats & Acknowledgements</h3>\n\n<p>We'll keep those pages as is, since there are no examples.</p>\n\n<pre id=\"c10fc3\"><code class=\"md hljs\">- Not tested against or designed to handle malformed HTML or CSS\n- Excessive escaping or reserved characters in your HTML or CSS can break TrapCSS's parsers</code></pre>\n\n<pre id=\"c10fc4\"><code class=\"md hljs\">- Felix Böhm's [nth-check](https://github.com/fb55/nth-check) - it's not much code, but getting `An+B` expression testing exactly right is frustrating. I got part-way there before discovering this tiny solution.\n- Vadim Kiryukhin's [vkbeautify](https://github.com/vkiryukhin/vkBeautify) - the benchmark and test code uses this tiny formatter to make it easier to spot differences in output diffs.</code></pre>\n\n</div>\n\n<p>This should be it for Wiki. Now it's attached to our project and will always be available on <em>GitHub</em>.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='28' height='9'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/4.svg\"></noscript></a>\n</p>\n</div>\n\n<div data-section id=\"license\">\n<h2>License</h2>\n\n<p>I'd like to update our footer to include the information about the original license. I've chosen Affero for this project, so the footer at the moment looks like the following:</p>\n\n<pre id=\"c10fc5\"><code class=\"md hljs\">## Copyright &amp; License\n\nGNU Affero General Public License v3.0</code></pre>\n\n<p>Let's include the original license:</p>\n\n<pre id=\"c10fc6\"><code class=\"md hljs\">## Copyright &amp; License\n\nGNU Affero General Public License v3.0\n\nOriginal work on [_DropCSS_](https://github.com/leeoniya/dropcss) package\nby [Leon Sorokin](https://github.com/leeoniya) under MIT license found in [COPYING](COPYING).</code></pre>\n\n<p>There are 2 standard files for a license, either <span class=\"tm2\">LICENSE</span> or <span class=\"tm2\">COPYING</span>. Since our AGPL is found in the former, we can include the original one in the latter. This is the convention I use for forked packages. I'll also update <strong>package.json</strong> to include the original license in the <span class=\"tm\">files</span> field:</p>\n\n<pre id=\"cb9de2\"><code class=\"json hljs\">\"files\": [\n  \"src\",\n  \"compile\",\n  \"types/externs.js\",\n  \"typedefs.json\",\n  \"COPYING\"\n]</code></pre>\n\n<p>The <span class=\"tm2\">LICENSE</span> is always included by npm / yarn, so we don't need to specify it in there. We also want to publish the source code, so that the package can be compiled into other packages. If you're not publishing source code, remember to still include <strong>src/bin/index.js</strong> since it's defined in the <span class=\"tm\">bin</span> field, and <em>npm</em> will not let you install the package if the file is missing (unlike <em>yarn</em>). <strong>typedefs.json</strong> will contain meta-information for package's types so that they can be linked to from other packages:</p>\n\n<pre id=\"cb9de3\"><code class=\"json hljs\">{\n  \"_trapcss.trapcss\": {\n    \"link\": \"https://github.com/artdecocode/trapcss#trapcssconfig-config-return\",\n    \"description\": \"Parses the supplied HTML and CSS and removes\\nunused selectors. Also removes empty CSS rules.\"\n  },\n  \"_trapcss.Config\": {\n    \"link\": \"https://github.com/artdecocode/trapcss#type-config\",\n    \"description\": \"Options for the program.\"\n  },\n  \"_trapcss.Return\": {\n    \"link\": \"https://github.com/artdecocode/trapcss#type-return\",\n    \"description\": \"Return Type.\"\n  }\n}</code></pre>\n\n<p>We'll come back to it in a second.</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='10'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/5.svg\"></noscript></a>\n</p>\n</div>",
  "file": "trapcss2",
  "postAjax": "(function imgPostAjax() {\n  /* eslint-env browser */\n  window['IO']()\n  window['WEBP']()\n})()"
}