{
  "title": "TrapCSS 2: Advanced NodeTools",
  "content": "\n\n<div data-section id=\"trapcss-2\">\n<h1>TrapCSS2: Advanced NodeTools</h1>\n\n<p>In the previous part, we looked at the first steps in creating a new package with <em>NodeTools</em> stack. During the initialisation process with <span class=\"tm\">mnp</span>, we were asked some questions like if we wanted to compile the package, if a binary should be added and whether <em>GitHub</em> wiki should be created. We answered yes to all three questions, so let's get on with the second part of the tutorial.</p>\n\n<p>\n  <img class=\"ImageHolder b-vk b-t\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\" alt=\"trapcss2: advanced nodetools tutorial (car splash)\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='1000' height='668'/%3E\">\n  <noscript>\n    <picture>\n      <source\n        srcset=\"/nodetools/pages/trapcss2/img/trapcss2-768.webp 768w,/nodetools/pages/trapcss2/img/trapcss2-576.webp 576w,/nodetools/pages/trapcss2/img/trapcss2-319.webp 319w,/nodetools/pages/trapcss2/img/trapcss2-1000.webp 1000w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\"\n        type=\"image/webp\">\n      <img class=\"b-vk b-t\" onLoad=\"webploaded(this)\" alt=\"trapcss2: advanced nodetools tutorial (car splash)\" src=\"/nodetools/pages/trapcss2/img/trapcss2-768.jpg\" srcset=\"/nodetools/pages/trapcss2/img/trapcss2-768.jpg 768w,/nodetools/pages/trapcss2/img/trapcss2-576.jpg 576w,/nodetools/pages/trapcss2/img/trapcss2-319.jpg 319w,/nodetools/pages/trapcss2/img/trapcss2-1000.jpg 1000w\" sizes=\"(max-width: 575.8px) 100vw,(max-width: 991.8px) 540px,(max-width: 1199.8px) 720px,855px\">\n    </picture>\n  </noscript>\n</p>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='15'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/0.svg\"></noscript></a>\n</p>\n</div>\n\n<div data-section id=\"welcome-closure\">\n<h2>Welcome Closure</h2>\n\n<p>Prior to <em>NodeTools</em>, the industry standard was to simply transpile source code with <em>Babel</em>, or not use modules at all and avoid transpilation step altogether. The first option is not good because <em>Babel</em> is a package with 250+ dependencies that jam our <span class=\"tm2\">node_modules</span>, and also because for years it's been disparaging professional software engineering values that are in core of <em>NodeTools</em>, such as respect for <em>JSDoc</em>, as can be read in the <a href=\"/nodetools/babel-when-open-source-is-not-free-sofware.html\">\n   Babel: When Open Source Is Not Free Sofware</a> article. The second option is not applicable either as I believe in embracing innovation and keeping up with the newest technological advances to be able to be productive and remain competent and competitive.</p>\n\n<p>Because <span class=\"tm\">NearForm</span>, the <a href=\"https://www.nearform.com/community/\">largest contributor</a> to Node.JS with labour resource of over 100 people, extorted back-end engineers into using <em>Babel</em> by not implementing ECMA modules since 2015, the actual state of art of modern package making is pretty sad. Those working on <em>Babel</em> took the advantage of that forced downloads count to call their buggy product a compiler, which is not true. It's popular only because people had no choice rather because it's exceptional in any way. A compiler is a sophisticated piece of software so there must be something special about a program to be called this name (rather than a transpiler). <em>Closure Compiler</em> is software that will check types and perform advanced passes like peep-hole optimisation and function call folding, therefore it really deserves this title.</p>\n\n<p>Up until <em>NodeTools</em>, there were 4 ways to create <strong>Node.JS</strong> packages:</p>\n\n<ol>\n  <li><strong>old-school</strong>, by keeping <span class=\"tm\">module.exports</span> and not taking advantage of modules' syntax which is one of the best features of JavaScript;</li>\n  <li><strong>alternative</strong>, that included an additional bundle up step, with such software as rollup and webpack;</li>\n  <li><strong>TypeScript</strong>, which is a corporate paradigm that has swept the world due to the lack of professional tools that could compete with it to provide good routines for working with types;</li>\n  <li><strong>Babel</strong>, the mass-mentality industry pattern that has no respect for its users, whose authors self-proclaimed themselves leaders of the sector while failing miserably to meet essential requirements for a transpiler.</li>\n</ol>\n\n<p><em>NodeTools</em> is a new, <strong>indie</strong> replacement to all these methods that allows to leave them behind and focus on JS coding. We provide the most light-weight, pure <em>JavaScript</em> solution that would allow to develop professional packages and keep independent from 3rd party software that dictates how you should work and what <em>your</em> code should look like. The developer and her freedom is our top priority. For example, there's literally no config for compiling you packages, and all annotations are based on the open JSDoc standard. You can still choose the language output (such as ECMA2015-2019) and control other options like pretty printing via CLI arguments. <em>NodeTools</em> is the only methodology that starts to use <em>Closure Compiler</em> for packages, and it takes Node.JS software development to the next level.</p>\n\n<div data-section id=\"installation\">\n<h3>Installation</h3>\n\n<p><em>Closure Compiler</em> is developed by Google. It's used for mission-critical internal projects, that are not based on TypeScript. It's a Java program of the size of 10MB that can be installed once on the system, and using advanced optimisations, can put the source code, as well as all liked dependencies into a single executable file. In other words, it provides static linking for libraries into our generated code. Type checking now becomes the final stage of the development process that provides insight into small inaccuracies in our types, instead of forcing us to think in terms of types, like in <em>TypeScript</em>.</p>\n\n<p>To use the compiler, you'll need Java on your machine. If you're working on Windows, you can just install it from the official website and it'll be working fine. On a Mac, I had to add the following line to my <span class=\"tm2\">~/.bash_profile</span>.</p>\n\n<pre id=\"c414d2\"><code class=\"bash hljs\">export JAVA_HOME=/Library/Internet\\ Plug-Ins\\JavaAppletPlugin.plugin/Contents/Home</code></pre>\n\n<p>If you're using <strong>zsh</strong>, also add <span class=\"tm2\">source ~/.bash_profile</span> to your <strong>~/.zshrc</strong>. Then we're going to install <span class=\"tm\">google-closure-compiler-java</span> into the home folder:</p>\n\n<pre id=\"c414d\"><code class=\"bash hljs\">cd ~\nyarn|npm init # we want to save deps in package.json\nyarn add google-closure-compiler-java</code></pre>\n\n<p>\nYour distribution will be installed in the <strong>~/node_modules</strong> directory.\nOn top of the compiler itself, the actual package that executes the process, is called <em>Depack</em>. It's made possible to compile Node.JS package for the first time, since it wasn't possible before as when trying to compile back-end software with Closure, it would throw errors since it couldn't recognise internal Node API, such as <span class=\"tm\">fs</span>, <span class=\"tm\">stream</span>, <em>etc</em>. <em>Depack</em> fixes this by creating mock folders in your <span class=\"tm\">node_modules</span>,\nsuch as <strong>node_modules/fs/index.js</strong>,\n<strong>node_modules/fs/package.json</strong> that simply destructure the global API annotated via externs to enable type checking. We've implemented the externs for Node 8 API, which should also work with later versions.\n</p>\n\n<pre id=\"ccdbf\"><code class=\"javascript hljs\">// node_modules/child_process/index.js\n/* a mock of child process built-in */\n\nexport default child_process\nexport const {\n  ChildProcess,\n  exec,\n  execFile,\n  execFileSync,\n  execSync,\n  fork,\n  spawn,\n  spawnSync,\n} = child_process</code></pre>\n\n<pre id=\"ccdbf1\"><code class=\"javascript hljs\">// node_modules/child_process/package.json\n{\n  \"name\": \"child_process\",\n  \"main\": \"index.js\"\n}</code></pre>\n\n<p>You can use nightly versions of the compiler, if you want, by looking up the last version with <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span>info</span> <span>google-closure-compiler-java</span></span></span> and setting the exact version, e.g., <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-cmd\">i</span><span class=\"yarn-cmd\">add</span> <span>google-closure-compiler-java@20200201.0.0-nightly</span></span></span>. This can help if there are occasional bugs in the compiler, e.g., the January 2020 version has broken destructuring, so you need to use the nightly build like the one I've just mentioned. There's a list of bugs in the compiler in the <a href=\"https://github.com/dpck/depack/wiki/Bugs\"><em>Depack</em> wiki</a>.</p>\n\n<p><em>Closure</em> is written in Java. You can fork <a href=\"https://github.com/google/closure-compiler\">their project</a> and study how it works. There's a lot of useful information on the <a href=\"https://github.com/google/closure-compiler/wiki\">Wiki</a>, especially in the types section. It might seem complex at first, but I managed to fix certain issues with PRs by only studying the source code for a few days. A compiler is based on AST passes, where you can manipulate nodes. There's also a JSDoc parser, and an inner project for JS source map consumption/generation. When you make a change, you build the compiler locally. Then you can set the <span class=\"tm\">GOOGLE_CLOSURE_COMPILER</span> env variable with the path to your target JAR, which will then be used by <em>NodeTools</em>.</p>\n\n<!-- end installation -->\n</div>\n\n<div data-section id=\"advantages\">\n<h3>Advantages</h3>\n\n<p>Some might say that we're still tied up to the compiler, but it's much better than Babel and TypeScript, because:</p>\n\n<ul>\n  <li>You don't need to install 250 dependencies just for your modules' syntax via <em>Babel</em>.</li>\n  <li>The bin size is 10mb instead of 50mb of <span class=\"tm\">TypeScript</span>.</li>\n  <li>You can statically link packages like in proper software engineering.</li>\n  <li>Compiler will produce type hints for you that are useful to polish your programs, but don't lock you into a completely different language which TS is.</li>\n  <li>It's meant for pure JavaScript development which is great.</li>\n  <li>Its advanced optimisation obfuscates code so that you can send it to your clients with a bit more security for your intellectual property.</li>\n  <li>You can compile complex back-end applications into a single JS file, for example, we created <a href=\"https://github.com/idiocc/idio\">Idio</a> which is a Koa server with essential middleware that only has 2 dependencies (<span class=\"tm\">mime-db</span> and <span class=\"tm\">text-decoding</span> which are databases for processing encoded data). Without compilation, <span class=\"tm2\">Idio</span> would have to download around 130 external dependencies.</li>\n  <li>It's maintained by <em>Google</em> themselves by top-level software engineers who know compiler theory, so you can rely on compilation results.</li>\n  <li>You don't have to compile, and simple transpilation is also possible without <em>Closure</em>.</li>\n  <li>You can keep the source code of your larger packages non-compiled, but instead compile only its dependencies into a file called <em>StdLib</em>.</li>\n</ul>\n\n<p>Additionally, another reason to learn about compiler and externs, is because the highest paid Software Engineering positions are for <span class=\"tm2\">Clojure</span> language, around $140k per year <a\n  href=\"https://insights.stackoverflow.com/survey/2019#technology-_-what-languages-are-associated-with-the-highest-salaries-worldwide\">\n  in the US</a>. When you're working on <em>Clojure</em> projects, you'll be writing your front-end in <em>ClojureScript</em>, that produces JavaScript compatible with <em>Closure Compiler</em>, so you'll need to understand how externs work. If you learn it via <em>NodeTools</em> today, you'll be prepared to become one of the highest-paid developers in the world if you decide to specialise in <em>Clojure</em> at some point.</p>\n\n<!-- end advantages -->\n</div>\n\n<div data-section id=\"web-bundling\">\n<h3>Web Bundling</h3>\n\n<p><em>NodeTools</em> is a holistic package development methodology. The compiler works together with all other tools, such as Typal, that allows to maintain a single source of truth for your types and generate externs for the compiler, Documentary that can embed and interlink such type information in documentation of packages including wikis, and <em>Zoroaster</em> that provides API to test forks as well as letting you test your target compiled code, instead of only source code, which is an absolute must when taking advantage of the advanced compilation mode.</p>\n\n<p>The primary realm of our stack is Node.JS package development, however with <em>Depack</em> you can also develop and compile <a href=\"https://github.com/art-deco/akashic.page\">web-bundles</a>, as there's also support for JSX syntax in <em>ÀLaMode</em>. It's based on regexes, but we've managed to create many nice widgets for the web with it. We'll be advertising the web stack features later on. We hope that the tools that we provide in only 10 <span class=\"tm\">node_modules</span> folders, will really allow to have a breath of fresh air in this stale-air environment where people adapt to paradigms, instead of using such powerful language as JavaScript to their maximum advantage.</p>\n\n<p>You can read about compiling front-end JavaScript code in the <a href=\"/nodetools/web-development-with-nodetools.html\">Web Development With NodeTools</a> article.</p>\n\n<!-- end web -->\n</div>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/1.svg\"></noscript></a>\n</p>\n</div>\n<!-- </div> -->\n\n<div data-section id=\"compiling-packages\">\n<h2>Compiling Packages</h2>\n\n<p>Let's get down to business. Advanced compilation means that our comments are going to be stripped off the source code, so that all type information is lost. It's possible to preserve all comments, however this is a new feature of the compiler, and will keep ALL comments which might be undesirable. We'll be compiling our API, so the strategy is the following:</p>\n\n<ol>\n  <li>to compile the source code into a file that exports API methods,</li>\n  <li>to import those API methods from another file that wraps them in JSDoc.</li>\n</ol>\n\n<p>\n  <img class=\"b-t\" alt=\"source compile and entry JS files\" data-io>\n  <noscript>\n    <img class=\"b-t\" alt=\"source compile and entry JS files\" src=\"/nodetools/pages/trapcss2/1-compile/img/source-compile-entry.gif\">\n  </noscript>\n</p>\n\n\n<div data-section id=\"templates\">\n<h3>Templates</h3>\n\n<p>The entry point for the compiler is <strong>src/depack.js</strong>, which imports the method from the source code and exports it via CommonJS standard. It also imports externs so that <em>Closure</em> will understand our types:</p>\n\n<pre id=\"ccdbf8\"><code class=\"javascript hljs\">import '../types/externs'\nimport trapcss from './'\n\n/*!\n * trapcss: Removes unused selectors from CSS files to achieve\n * maximum optimisation. Can be used as an API function or with CLI.\n *\n * Copyright (C) 2020  Art Deco Code Limited\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU Affero General Public License as\n * published by the Free Software Foundation, either version 3 of the\n * License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU Affero General Public License for more details.\n *\n * You should have received a copy of the GNU Affero General Public License\n * along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.\n */\n\n// export default {\nmodule.exports = {\n  '_trapcss': trapcss,\n}\n</code></pre>\n\n<p>This file also includes the APGL license that was selected when the package was bootstrapped. It uses the <span class=\"tm2\">/*!</span> notation to preserve the comment. If you chose MIT license, you'll also have a similar, but shorter notice. For other licenses, you'd have to add a comment manually. Also, for <em>AGPL</em>, we don't include the copyright on top of each file as I believe it's redundant, but feel free to do it your way.</p>\n\n<p>The entry to <em>Depack</em> imports our API, and assigns it to the <span class=\"tm\">modules.export</span> object. This will allow to access those methods (currently, just 1) from the <strong>compile</strong> dir. However, because we ran the <em>ÀLaMode</em> transpiler on the <strong>src</strong> folder, the <span class=\"tm\">module.exports =</span> got renamed into <span class=\"tm\">export default</span>, therefore just manually change it back now.</p>\n\n<p>We'll need to create a second file, called <span class=\"tm2\">template</span> in <strong>compile/template.js</strong>:</p>\n\n<pre id=\"ccdbf9\"><code class=\"javascript hljs\">const { _trapcss } = require('./trapcss')\n\n/**\n * @methodType {_trapcss.trapcss}\n */\nfunction trapcss(config) {\n  return _trapcss(config)\n}\n\nmodule.exports = trapcss\n\n/* typal types/index.xml namespace */\n</code></pre>\n\n<p>The template file is not meant for execution, but provides a blueprint for generation of our <span class=\"tm\">main</span> file (called main because of the main field in <strong>package.json</strong>). It has the <span class=\"tm\">@methodType {_trapcss.trapcss}</span> annotation, that declares the type of the function, so that its JSDoc can be expanded. It also contains the <span class=\"tm\">typal</span> marker at the bottom, so that we can embed our <em>Config</em> and <em>Return</em> types into the main file as well. To generate the real JavaScript file, we'll need to run the <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>d</span></span></span> command, that will run <span class=\"tm\">template</span> and <span class=\"tm\">d1</span> scripts in series. The template command is the following: <span class=\"tm2\">typal compile/template.js -T compile/index.js -t types/api.xml</span>:</p>\n\n<ul>\n  <li><strong>compile/template.js</strong>, is the path to the template file.</li>\n  <li><strong>-T compile/index.js</strong>, the path to the main file to be generated.</li>\n  <li><strong>-t types/api.xml</strong>, is the path to types that should be used. It could also point to the dir itself, however because we also included arguments.xml for our binary, that doesn't allow us to simply pass <span class=\"tm\">types</span>.</li>\n</ul>\n\n<p>The <span class=\"tm\">d1</span> command expands the typal marker in the <strong>index.js</strong> produced from the template &mdash; <span class=\"tm2\">typal compile/index.js types/index.js -u -t types/index.xml</span>:</p>\n\n<ul>\n  <li><strong>compile/index.js types/index.js</strong>, paths to files with <span class=\"tm2\">typal</span> markers that needs embedding typedefs.</li>\n  <li><strong>-u</strong>, tells <em>Typal</em> to use namespaces rather than simple type names.</li>\n  <li><strong>-t types/index.xml</strong>, the location of types, can be skipped.</li>\n</ul>\n\n<p>After the two commands are run, we'll have a production-ready entry file. Let's have a look at what is being produced as the <span class=\"tm\">main</span>:</p>\n\n<pre id=\"ccdbf10\"><code class=\"javascript hljs\">const { _trapcss } = require('./trapcss')\n\n/**\n * Parses the supplied HTML and CSS and removes\nunused selectors. Also removes empty CSS rules.\n * @param {_trapcss.Config} config Options for the program.\n * @param {string} config.html The input HTML.\n * @param {string} config.css The CSS to drop selectors from.\n * @param {boolean} [config.keepAlternate=false] Whether to keep the `@alternate` comment for\n * Closure Stylesheets. Default `false`.\n * @param {(sel: string) =&gt; boolean} [config.shouldDrop] Whether _TrapCSS_ should remove this selector.\n * The `shouldDrop` hook is called for every CSS selector\n * that could not be matched in the html. Return `false`\n * to retain the selector or `true` to drop it.\n * @return {_trapcss.Return}\n */\nfunction trapcss(config) {\n  return _trapcss(config)\n}\n\nmodule.exports = trapcss\n\n/* typal types/index.xml namespace */\n/**\n * @typedef {_trapcss.Config} Config `＠record` Options for the program.\n * @typedef {Object} _trapcss.Config `＠record` Options for the program.\n * @prop {string} html The input HTML.\n * @prop {string} css The CSS to drop selectors from.\n * @prop {boolean} [keepAlternate=false] Whether to keep the `@alternate` comment for\n * Closure Stylesheets. Default `false`.\n * @prop {(sel: string) =&gt; boolean} [shouldDrop] Whether _TrapCSS_ should remove this selector.\n * The `shouldDrop` hook is called for every CSS selector\n * that could not be matched in the html. Return `false`\n * to retain the selector or `true` to drop it.\n * @typedef {_trapcss.Return} Return `＠record` Return Type.\n * @typedef {Object} _trapcss.Return `＠record` Return Type.\n * @prop {string} css The dropped CSS.\n * @prop {!Set&lt;string&gt;} sels The used selectors.\n */\n</code></pre>\n\n<p>The entry file to our package contains an annotated function that wraps a method from the API. Since we decorated it with JSDoc, we'll be able to receive autocompletion hints on the config type when consuming the library from other packages. Our config is declared as a type at the bottom, but the <span class=\"tm\">config</span> property of the function is also expanded into individual <span class=\"tm2\">@param</span>s. This is to increase the visibility of the parameters, which will now appear on the function's description:</p>\n\n<p>\n  <img class=\"b-vk b-t\" alt=\"visibility of the config type for the method\" data-io>\n  <noscript>\n    <img class=\"b-vk b-t\" alt=\"visibility of the config type for the method\" src=\"/nodetools/pages/trapcss2/1-compile/img/vis.png\">\n  </noscript>\n</p>\n\n<p>This allows people to read the full description of the argument, without having to go through each individual property when expanding the config. Without this feature, the description doesn't give the full picture:</p>\n\n<p>\n  <img class=\"b-vk b-t\" alt=\"limited visibility of the config type\" data-io>\n  <noscript>\n    <img class=\"b-vk b-t\" alt=\"limited visibility of the config type\" src=\"/nodetools/pages/trapcss2/1-compile/img/vis2.png\">\n  </noscript>\n</p>\n\n<p>All typedefs should be embedded into the main file, which acts as a repository for types. This will make sure that types are always available. Do you remember how we imported the config type from <strong>types/index.js</strong> in the previous part?</p>\n\n<pre id=\"ccdbf2\"><code class=\"javascript hljs\">/**\n * @typedef {import('..').Config} _trapcss.Config\n * @typedef {import('..').Return} _trapcss.Return\n */</code></pre>\n\n<p>This is because the main file is treated as the go-to place for types. Using templates allows to treat source code independent from the API specification, and plug in the implementation into JSDoc-annotated shells for code. It's kind of similar to TypeScript that provides <span class=\"tm\">.d.ts</span> types, however in pure JavaScript. If you're exporting a class, you can also use the <span class=\"tm\">@constructor</span> tag in the template, to generate a class shell.</p>\n\n<pre id=\"ccdbf3\"><code class=\"javascript hljs\">const { _Cl } = require('./depack')\n\n/** @constructor {_ns.MyClass} */\nclass MyClass extends _Cl {}</code></pre>\n\n<p>The body of the class will then be generated, however there's no annotations for properties, only member methods. For example, <span class=\"tm2\">@goa/router</span> <a href=\"https://github.com/idiocc/goa-router/blob/master/compile/index.js\">uses</a> this method. <a\n  href=\"https://github.com/idiocc/koa/blob/b6a2ebed556006675a35c1dcf7ee28aacdc3271c/compile/index.js#L7\">\n  Another way</a> to template classes, is to include a typedef of a class in a file, and then use <span class=\"tm\">typeof</span> operator when proxying the type:</p>\n\n<pre id=\"ccdbf4\"><code class=\"javascript hljs\">const { _Goa, _Context } = require('./koa')\n\n/**\n * An application constructor.\n * @type {new (options?: ApplicationOptions) =&gt; Application)}\n */\nconst $Goa = _Goa\n\n/**\n * The default context constructor.\n * @type {new () =&gt; Context}\n */\nconst $Context = _Context\n\nmodule.exports = $Goa\nmodule.exports.Context = $Context</code></pre>\n\n<p>This also works pretty well, however you won't be able to access JSDoc for static methods.</p>\n\n<hr />\n\n<p>In short, we need to use templates to enrich our compiled code with JSDoc annotations, by providing simple shells that are documented with JSDoc comments. All typedefs are also included in the main JS file to be accessed by methods. They are also imported from the source code, either directly or via such files as <strong>types/index.js</strong> that hold methods' typedefs for development purposes, as the main file is the source of truth for types.</p>\n\n</div>\n\n<div data-section id=\"running-compiler\">\n<h3>Running Compiler</h3>\n\n<p>The next step is to execute the compiler. The package that we installed contained a <strong>jar</strong> file, which needs to be passed to Java along with arguments. The arguments must also contain the list of all JS files in the program. That's why <em>Depack</em> also contains a regex-based static analysis tool that scans all files for <span class=\"tm\">import</span> statements, and builds a full list of all files. The algorithm can also detect <span class=\"tm\">require</span> calls, however if at some point you want to use dynamic linking (so that a dependency is required at runtime, rather than compiled into your program), you can use the following construct:</p>\n\n<pre id=\"ccdbf5\"><code class=\"javascript hljs\">const pckg = require(/* depack */ 'dynamic-linking')</code></pre>\n\n<p>In this case, the regex won't pick up the require call. In addition, no require calls from the entry file that we're compiling end up in the arguments. Initially, this was a bug, but I decided to keep it as is, so that in binaries, we can simply do something like that:</p>\n\n<pre id=\"ccdbf6\"><code class=\"javascript hljs\">if (_version) {\n  console.log('v%s', require('../../package.json')['version'])\n}</code></pre>\n\n<p>Importing JSON files with <span class=\"tm\">import</span> also doesn't work in Closure (at least at the time of writing), so you'll need to require them, or read as text and use JSON.parse method to extract JS objects from them.</p>\n\n<p>Since we've prepared and tested our source code already, we can just execute the compiler with <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>lib</span></span></span> command &mdash; <span class=\"tm2\">depack src/depack.js -o compile/trapcss.js -a -c -p --source_map_include_content</span>:</p>\n\n<ul>\n  <li><strong>src/depack.js</strong>, the entry point to compile.</li>\n  <li><strong>-o compile/trapcss.js</strong>, the output location.</li>\n  <li><strong>-a</strong>, enable advanced optimisation.</li>\n  <li><strong>-c</strong>, indicates to <em>Depack</em> that we're <strong>c</strong>ompiling a Node.JS package which enables Node externs.</li>\n  <li><strong>--source&lowbar;map&lowbar;include&lowbar;content</strong>, to include content in source maps. The content is pretty useful, however VSCode won't be able to print the values of variables when you hover over then during <a href=\"https://github.com/Microsoft/vscode/issues/12066\">debugging</a> in which case you might want to pass <span class=\"tm\">&quot;sourceMaps&quot;: false</span> in your launch config when debugging compiled libs.</li>\n</ul>\n\n<p>Other options could include <span class=\"tm\">-p</span>, for pretty output, or <span class=\"tm\">-O ES5</span>, to compile into really old code that could probably be able to run on Node 4 (given the API is supported). The default language output is ES2018. Source maps could be disabled with <span class=\"tm\">-S</span>. Any other <a href=\"https://github.com/google/closure-compiler/wiki/Flags-and-Options\">options</a> to the compiler can also be just passed after the main command. And that's it, there's no config or anything.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"compilation process\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='889' height='652'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"compilation process\" src=\"/nodetools/pages/trapcss2/1-compile/img/compile.gif\">\n  </noscript>\n</p>\n\n<p>Because of type checking, we also received a number of warnings. In part I, we kept the <span class=\"tm\">keepText</span> argument, even though it wasn't used in the source code. The compiler was able to pick up the fact that the config type does not include such property, and that the <span class=\"tm2\">parseHTML</span> method doesn't accept the second argument either. It's really great to use compiler to polish our code so that there are no inaccuracies like that left and our source is 100% professional. It is not possible with <em>Babel</em>, perhaps only with <em>TypeScript</em>.</p>\n\n<p>When we come to remove the <span class=\"tm\">keepText</span> to fix the warning, let's also add the original MIT copyright on the package. The copyright owner didn't include any comment that would have to be preserved, therefore we're under no obligation to include it in our code (only in documentation), but let's do it anyway as good practice. I use the following template for MIT:</p>\n\n<pre id=\"ccdbf7\"><code class=\"javascript hljs\">/*!\n * dropcss by Leon Sorokin\n * https://github.com/leeoniya/dropcss\n * Copyright(c) 2020\n * MIT Licensed\n */</code></pre>\n\n<p>The compiled code is saved into <strong>compile/trapcss.js</strong> file. Let's just have a quick look.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"compiled code\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='972' height='619'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"compiled code\" src=\"/nodetools/pages/trapcss2/1-compile/img/compiled.gif\">\n  </noscript>\n</p>\n\n<p>There's the <span class=\"tm\">use strict</span> directive, both licenses and the assignment to the <span class=\"tm2\">module.exports</span> property. On top, there's also a shebang which is not relevant to compiled libraries, but is needed when we'll be compiling binaries, however <em>Depack</em> just keeps it anyway since it doesn't have any negative effect. If you need to disable <span class=\"tm\">use strict</span>, you can pass the <span class=\"tm\">-s</span> flag to <em>Depack</em>.</p>\n\n\n\n<p>The template has already been prepared so now we actually have our package ready to be published, but we'd like to test the compiled module prior to publishing. Since we should be careful with advanced optimisation that can rename property names, we can now run all our tests but override the import of the source code to import of the compiled code. This is achieved with <span class=\"Manager\"> <span><span class=\"yarn-cmd\">yarn </span><span class=\"npm-cmd\">npm </span><span class=\"npm-run\">run </span><span>test-compile</span></span></span> command &mdash; <span class=\"ItWillRunYarn\"><span class=\"tm2\">yarn test -e test-compile</span></span><span class=\"ItWillRunNpm\"><span class=\"tm2\">npm test -- -- -e test-compile</span></span>. It simply calls the test script, but passes the <span class=\"tm\">test-compile</span> variable as testing environment. The environments are configured in the <span class=\"tm\">.alamoderc</span> file:</p>\n\n<pre id=\"cb9de\"><code class=\"json hljs\">{\n  \"env\": {\n    \"test-compile\": {\n      \"import\": {\n        \"replacement\": {\n          \"from\": \"^((../)+)src$\",\n          \"to\": \"$1compile\"\n        }\n      }\n    }\n  }\n}</code></pre>\n\n<p>Now every time we require <span class=\"tm\">../../src</span> from test, the transpiler will update it to <span class=\"tm\">../../compile</span> on the fly. We can also set it to just <span class=\"tm\">../..</span> since it will resolve to our <strong>package.json</strong> and read the <span class=\"tm2\">main</span> field from there. To ensure that the remapping actually happens, we can add a simple <span class=\"tm\">throw new Error(1)</span> in the <strong>compile/index.js</strong> file and try to run this command.</p>\n\n<pre id=\"c414d1\"><code class=\"bash hljs\">Testing compile bin\nError: 1\nCould not require test/spec\n    at Object.&lt;anonymous&gt; (/Users/zavr/adc/trapcss/compile/index.js:2:7)\n    at Module.p._compile (/Users/zavr/adc/trapcss/node_modules/alamode/compile/depack.js:49:18)\n    at Object.h.(anonymous function).y._extensions.(anonymous function) [as .js] (/Users/zavr/adc/trapcss/node_modules/alamode/compile/depack.js:51:7)\nerror Command failed with exit code 1.</code></pre>\n\n<p>There was an error, so the imports renaming was correct. Let's remove the error and run test again.</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"compiled code tests passing\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='604' height='466'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"compiled code tests passing\" src=\"/nodetools/pages/trapcss2/1-compile/img/tests.gif\">\n  </noscript>\n</p>\n\n<p>All tests pass which is good news! We can also create a test file called <span class=\"tm\">t.js</span> in the project dir, and import the library to test for the presence of autocompletions:</p>\n\n<p>\n  <img class=\"b-bk b-vk b-t\" alt=\"test for autocompletions\" src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='600' height='359'/%3E\" data-io>\n  <noscript>\n    <img class=\"b-bk b-vk b-t\" alt=\"test for autocompletions\" src=\"/nodetools/pages/trapcss2/1-compile/img/auto.gif\">\n  </noscript>\n</p>\n\n<p>After manual testing, we find that everything is correct. In <em>NodeTools 2</em>, we'll include a tool to write autocompletion tests since it's not feasible to keep rerunning such tests by hand. But for now, you can use this strategy.</p>\n\n<!-- Lastly, if the copyright owner included the copyright note in his source code, it would had to be preserved also according to MIT. However, he didn't and I didn't bother adding it in the source code. However, we'll want to document it  -->\n\n</div>\n\n<p class=\"SectionBreak\">\n  <a title=\"Back To Top\" href=\"#top\">\n    <img alt=\"section break\"\n      src=\"data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='40' height='13'/%3E\" data-io>\n    <noscript><img alt=\"section break\" src=\"/nodetools/section-breaks/2.svg\"></noscript></a>\n</p>\n</div>",
  "file": "trapcss2",
  "postAjax": "(function imgPostAjax() {\n  /* eslint-env browser */\n  window['IO']()\n  window['WEBP']()\n})()"
}